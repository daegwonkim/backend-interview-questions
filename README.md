<div align="center">
  <a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.demolab.com?font=Black+Han+Sans&size=40&duration=3000&pause=1000&color=0EBB12&center=true&vCenter=true&width=450&lines=%EB%B0%B1%EC%97%94%EB%93%9C+%EA%B0%9C%EB%B0%9C%EC%9E%90+%EB%A9%B4%EC%A0%91+%EC%A7%88%EB%AC%B8+%EC%A0%95%EB%A6%AC" alt="Typing SVG" /></a>  
</div>

## 🎯 Introduction

백엔드 개발 면접을 준비하면서 정리한 질문과 답변 모음집입니다.  
CS, 아키텍처, 프로그래밍 언어, 프레임워크, 데이터베이스, 백엔드, 보안 관련 내용을 다룹니다.  
주관적인 내용을 포함하고 있습니다.

## 📌 Index

- [CS](#-cs)
  - [운영체제](#운영체제)
  - [네트워크](#네트워크)
  - [자료구조/알고리즘](#자료구조알고리즘)
- [Architecture](#-architecture)
- [Programming Language](#%E2%80%8D-programming-language)
  - [공통](#공통)
  - [Java](#java)
- [Framework](#%EF%B8%8F-framework)
  - [Spring](#spring)
- [Database](#-database)
- [Backend](#-backend)
- [Security](#%E2%80%8D%EF%B8%8F-security)

## 💡 Questions

### 🖥 CS

#### 운영체제

<details>
  <summary>프로세스와 스레드의 차이에 대해 설명해주세요.</summary><br>
  
  프로세스와 스레드는 운영체제에서 <b>실행의 단위</b>를 나타내는 개념입니다.<br>
  
  <b>프로세스</b>는 현재 실행 중인 프로그램을 의미하고, 각 프로세스는 독립적인 메모리 공간을 가지고 있으며, 다른 프로세스와 완전히 분리되어 있습니다.<br>
  
  <b>스레드</b>는 프로세스 내에서 실행되는 작업의 단위이며, 하나의 프로세스 안에 여러 개의 스레드가 있을 수 있습니다. 스레드들은 같은 프로세스의 메모리 공간(스택 영역 제외)을 공유합니다.<br>

  주요 차이점을 요약하면 다음과 같습니다.
  1. 프로세스는 독립적인 메모리 공간을 가지지만 스레드는 코드, 데이터, 힙 영역을 공유하고 스택 영역만 따로 갖습니다.<br>
  2. 프로세스 간에는 서로 통신을 통해서 자원을 공유하고 데이터를 주고받아야 하지만, 스레드는 공유 메모리를 통해서 쉽게 데이터를 공유할 수 있습니다.<br>
  3. 프로세스는 하나의 프로세스가 죽어도 다른 프로세스에 영향을 주지 않지만, 스레드는 하나에 문제가 생기면 해당 스레드를 포함하고 있는 전체 프로세스가 영향을 받을 수 있습니다.
</details>

<details>
  <summary>스레드를 사용하는 이유에 대해 설명해주세요.</summary><br>

  스레드를 사용하는 가장 큰 이유는 <b>동시성을 통한 성능 향상</b>입니다.<br>

  단일 스레드로는 하나의 작업이 끝날 때까지 다른 작업을 할 수 없지만, 멀티 스레드를 사용하면 여러 작업을 동시에 처리할 수 있어 전체적인 처리량이 증가합니다.<br>

  또 파일 읽기, 네트워크 통신, 데이터베이스 쿼리와 같은 I/O 작업은 시간이 오래 걸리는데, 이때 다른 스레드가 CPU를 사용해서 다른 작업을 처리할 수 있어서 <b>I/O 블로킹 문제</b>도 해결할 수 있습니다.
</details>

<details>
  <summary>스레드는 최대한 많이 생성해서 사용하면 좋을까요?</summary><br>

  Java에서 각 스레드는 기본적으로 1~2MB 정도의 스택 메모리를 할당받습니다. 이는 결코 적은 양이 아니기 때문에 스레드를 무작정 많이 생성하면 추후에 <b>메모리 부족 현상</b>이 발생할 수 있습니다.<br>

  또한 CPU 코어의 수는 한정적인데 스레드 수만 많아지면 OS가 계속해서 스레드를 교체하면서 실행해야 하므로, 이 과정에서 발생하는 <b>컨텍스트 스위칭 오버헤드</b>로 인해 성능이 나빠질 수 있습니다.<br>

  더불어 스레드를 만들고 없애는 작업 자체도 시스템 리소스를 많이 사용하기 때문에 <b>스레드 생성 및 소멸 비용</b>도 무시할 수 없습니다.<br>

  따라서 스레드를 사용할 때에는 <b>Thread Pool</b>을 사용해서 적절한 개수의 스레드를 미리 생성해두고 재사용하는 방식을 주로 사용합니다.<br>

  결국에는 적절한 수가 핵심이고, 모니터링을 통해 최적의 스레드 수를 찾아가는 것이 중요합니다.
</details>

<details>
  <summary>메모리 구조에 대해 설명해주세요.</summary><br>
  
  메모리 구조는 크게 코드 영역, 데이터 영역, 힙 영역, 스택 영역으로 구분됩니다.<br>
  
  <b>코드 영역</b>은 실행할 프로그램의 코드가 저장되는 영역으로, 컴파일된 기계어 명령어들이 저장됩니다.<br>
  사용자가 프로그램 실행 명령을 내리면 OS에서는 디스크에서 메모리의 코드 영역으로 실행 코드를 올리게 되고, CPU는 코드 영역에 저장된 명령어를 하나씩 실행하게 됩니다.<br>

  <b>데이터 영역</b>은 프로그램 실행에 필요한 전역 변수와 정적 변수가 저장되는 영역입니다.<br>
  
  <b>힙 영역</b>은 동적으로 할당되는 메모리 공간으로, `malloc()`이나 `new`와 같은 함수로 런타임에 메모리를 요청할 경우 사용됩니다.<br>
  
  <b>스택 영역</b>은 함수 호출과 관련된 데이터가 저장되는 공간으로, 매개 변수나 지역 변수와 같은 데이터가 스택 프레임의 형태로 저장됩니다.<br>
  함수가 호출되면 스택에 스택 프레임이 쌓이고, 함수가 종료되면 스택 프레임이 제거되는 방식으로 동작합니다.
</details>

<details>
  <summary>컨텍스트 스위칭에 대해 설명해주세요.</summary><br>

  컨텍스트 스위칭이란 <b>CPU가 현재 실행중인 프로세스나 스레드의 실행을 중단하고 다른 프로세스나 스레드로 전환하는 과정</b>을 말합니다.<br>

  현재 실행중인 프로세스의 상태를 <b>PCB(Process Control Block)</b>에 저장하고, 다음에 실행할 프로세스의 상태를 PCB에서 불러와서 CPU 레지스터에 복원하는 방식으로 동작합니다.<br>

  컨텍스트 스위칭이 발생하는 기준은 다음과 같습니다.
  1. 시분할 시스템에서 타임 슬라이스가 끝난 경우
  2. I/O 작업으로 프로세스가 대기 상태에 들어간 경우
  3. 우선순위가 높은 프로세스가 대기열에 들어선 경우
  4. 프로세스가 종료된 경우
</details>

<details>
  <summary>CPU 스케줄링 알고리즘에 대해 설명해주세요.</summary><br>

  CPU 스케줄링 알고리즘이란 <b>여러 프로세스가 CPU를 사용하려고 할 때 어떤 순서로 CPU를 할당할지 결정하는 방법</b>을 말합니다.<br>

  <b>FCFS(First Come First Served) 스케줄링 기법</b>은 먼저 도착한 프로세스부터 처리하는 가장 간단한 방식으로, 공정하지만 작업 시간이 긴 프로세스가 먼저 도착하면 뒤의 짧은 작업들이 오래 기다려야 하는 <b>콘보이 현상</b>이 발생할 수 있습니다.

  <b>SJF(Shortest Job First) 스케줄링 기법</b>은 실행 시간이 가장 짧은 프로세스부터 처리하는 방식으로, 평균 대기 시간을 최소화할 수 있지만, 프로세스의 실행 시간을 미리 알기가 어렵고 실행 시간이 긴 프로세스의 경우에는 계속 실행이 지연되어 <b>기아 현상</b>이 발생할 수 있습니다.<br>

  <b>Round Robin 스케줄링 기법</b>은 각 프로세스에게 동일한 시간 할당량(타임 슬라이스)을 주고 돌아가면서 실행시키는 방식으로, 응답시간이 좋고 공정하지만 타임 슬라이스가 너무 짧으면 <b>컨텍스트 스위칭 오버헤드</b>로 인해 성능에 문제가 생길 수 있습니다.<br>

  <b>우선순위 스케줄링 기법</b>은 각 프로세스에 우선순위를 부여해서 높은 우선순위의 프로세스부터 처리하는 방식으로, 중요한 작업을 먼저 처리할 수 있지만 낮은 우선순위 프로세스의 경우 계속 실행이 지연되어 <b>기아 현상</b>이 발생할 수 있습니다.<br>

  <b>다단계 피드백 큐 스케줄링 기법</b>은 여러 개의 큐를 두고 프로세스의 행동에 따라 우선순위를 동적으로 조정하는 방식으로, CPU 집약적인 프로세스는 낮은 우선순위로, I/O 집약적인 프로세스는 높은 우선순위로 관리하며 CPU 실행 효율성을 높이는 기법입니다.

  > <b>콘보이 현상</b><br>
  > 콘보이 현상이란 작업 시간이 긴 프로세스에 의해 다른 프로세스의 실행이 전부 늦춰지는 현상을 말합니다.<br>
  > FCFS 스케줄링은 <b>비선점형 스케줄링 방식</b>으로, I/O 작업으로 인해 프로세스가 대기 상태로 전환되거나 프로세스가 완전히 종료되기 전까지는 다른 프로세스를 실행할 수 없기 때문에 이러한 현상이 발생할 수 있습니다.

  > <b>기아 현상</b><br>
  > 기아 현상이란 특정 프로세스가 계속해서 자원을 할당받지 못해 무한정 기다리게 되는 상황을 말합니다.<br>
  > 즉, SJF나 우선순위 스케줄링 방식에서 우선순위가 높은 프로세스들이 계속 들어오면서 우선순위가 낮은 프로세스는 영원히 실행되지 못하는 것을 의미하며, 이에 대한 가장 일반적인 해결책은 프로세스가 오래 기다릴수록 우선순위를 점진적으로 높여주는 <b>에이징(aging) 기법</b>을 사용하는 것입니다.
</details>

<details>
  <summary>선점형 스케줄링과 비선점형 스케줄링의 차이에 대해 설명해주세요.</summary><br>

  선점형 스케줄링과 비선점형 스케줄링은 <b>현재 실행중인 프로세스로부터 CPU를 강제로 빼앗을 수 있는지에 대한 개념</b>을 말합니다.<br>

  <b>비선점형 스케줄링</b>에서는 한 번 CPU를 할당받은 프로세스는 작업이 완료되거나 자발적으로 CPU 반납하지 않는 이상 계속 실행됩니다.<br>
  즉, 운영체제가 강제로 CPU를 빼앗을 수 없으며, 대표적인 예로 FCFS, SJF 스케줄링이 있습니다.<br>
  비선점형 스케줄링은 구현이 간단하고 컨텍스트 스위칭 오버헤드가 적지만, 작업 시간이 긴 프로세스가 CPU를 독점할 경우 응답 시간이 나빠질 수 있습니다.<br>

  <b>선점형 스케줄링</b>에서는 운영체제가 필요에 따라 현재 실행중인 프로세스로부터 CPU를 강제로 빼앗을 수 있습니다.<br>
  타임 슬라이스가 끝나거나 더 높은 우선순위 프로세스가 나타나면 현재 프로세스를 중단시키고 다른 프로세스를 실행하는 방식으로, 대표적인 예로 Round Robin이나 우선순위 스케줄링이 있습니다.<br>
  선점형 스케줄링은 응답 시간이 좋고 공정하지만, 컨텍스트 스위칭 오버헤드가 커질 수 있습니다.
</details>

<details>
  <summary>동기와 비동기의 차이에 대해 설명해주세요.</summary><br>

  동기와 비동기는 <b>프로그래밍 실행 방식</b>에 관한 개념으로, <b>작업의 완료를 기다리는지 여부</b>에 따라 구분됩니다.

  <b>동기(Synchronous)</b>는 작업을 순차적으로 실행하는 방식으로, 하나의 작업이 완전이 끝날 때까지 기다렸다가 다음 작업을 실행합니다.<br>
  이를 통해 작업의 순서를 보장하며, 이러한 방식은 일련의 파이프라인을 준수하는 구조에서 효율적입니다.

  <b>비동기(Asynchronous)</b>는 작업을 시작한 후 해당 작업에 대한 완료를 기다리지 않고 즉시 다음 작업을 진행하는 방식입니다.<br>
  이는 작업의 순서를 보장하지 않으며, 이러한 방식은 각 작업들이 독립적이거나 작업 별 지연이 큰 경우 효율적입니다.
</details>

<details>
  <summary>Blocking I/O와 Non-blocking I/O의 차이에 대해 설명해주세요.</summary><br>

  블로킹 I/O와 논블로킹 I/O는 <b>I/O 작업 요청 시 호출한 함수가 즉시 반환되는지 여부</b>에 따라 구분됩니다.

  <b>블로킹 I/O</b>는 I/O 작업을 요청했을 때 해당 작업이 완료될 때까지 호출한 함수가 반환되지 않고 대기하는 방식입니다. 이 과정에서 프로세스나 스레드는 다른 작업을 수행할 수 없으며, 커널이 I/O 작업을 완료하면 그 결과를 받아 다음 작업을 진행합니다.
  
  <b>논블로킹 I/O</b>는 I/O 작업을 요청했을 때 작업의 완료 여부와 관계없이 즉시 반환되는 방식입니다. 커널은 데이터가 준비되지 않았더라도 바로 응답하며(예: `EAGAIN` 에러), 이를 통해 애플리케이션은 대기하지 않고 다른 작업을 수행할 수 있습니다. 이후 주기적으로 폴링(polling)이나 이벤트 통지를 통해 I/O 작업 완료를 확인합니다.
</details>

<details>
  <summary>멀티 스레드 프로그래밍에 대해 설명해주세요.</summary><br>

  멀티 스레드 프로그래밍이란 <b>하나의 프로세스 내에서 여러 개의 스레드를 생성하여 작업을 병렬로 처리하는 프로그래밍 기법</b>입니다.<br>

  이때 각 스레드는 같은 프로세스의 메모리 공간(스택 영역 제외)을 공유하며, 독립적인 실행 흐름을 갖습니다.<br>

  멀티 스레드를 사용하면 CPU 코어를 효율적으로 활용할 수 있고, I/O 작업 중에도 다른 스레드가 작업을 계속할 수 있어서 전체적인 처리량이 늘어납니다.<br>

  다만, 여러 스레드가 공유 데이터에 동시에 접근하는 경우에는 예상치 못한 결과가 나오거나(Race Condition), 교착상태가 발생할 수도 있습니다.<br>

  따라서 멀티 스레드 환경에서는 뮤텍스, 세마포어 같은 동기화 도구를 사용해서 임계 영역에는 한 번에 하나의 스레드만 접근할 수 있도록 동기화 처리를 하는 것이 중요합니다.
</details>

<details>
  <summary>멀티 스레드 환경에서의 동기화 기법에 대해 설명해주세요.</summary><br>

  멀티 스레드 환경에서 공유 자원에 대한 접근을 제어해서 데이터의 일관성을 보장하는 방법으로 사용되는 도구는 크게 3가지가 있습니다.<br>

  <b>뮤텍스(Mutex)</b>는 가장 기본적인 동기화 도구로, <b>한 번에 하나의 스레드</b>만 임계 영역에 접근할 수 있도록 합니다.<br>
  즉, 임계 영역에 진입할 수 있는 열쇠가 하나 뿐이며, 특정 스레드가 락을 획득하면 다른 스레드들은 락이 해제될 때까지 기다려야 합니다.<br>

  <b>세마포어는(Semaphore)</b>는 뮤텍스를 일반화한 개념으로, <b>동시에 접근할 수 있는 스레드의 개수를 제한</b>하는 방식입니다.<br>
  즉, 정해진 카운트에 따라 임계 영역에 동시에 접근할 수 있는 스레드의 개수가 정해지며, 뮤텍스와 마찬가지로 락을 획득하고 해제하는 작업을 통해 동기화가 이루어집니다.<br>

  <b>모니터(Monitor)</b>는 뮤텍스에 <b>조건 변수</b>를 추가한 동기화 도구로, 조건 변수란 특정 조건이 참이 될 때까지 스레드를 대기시키는 도구를 말합니다. (주로 생산자-소비자 문제에서 버퍼가 비어있을 때 소비자를 기다리게 하는 용도로 많이 사용됨)<br>
  따라서 모니터는 단순한 락 획득/해제 뿐만 아니라 조건 변수를 통한 조건 기반 대기와 통지 매커니즘을 제공하여 더 정교한 제어가 가능합니다.
</details>

<details>
  <summary>레이스 컨디션에 대해 설명해주세요.</summary><br>

  레이스 컨디션(Race Condition)이란 <b>둘 이상의 프로세스나 스레드가 공유 자원에 동시에 접근하여 변경하려고 할 때, 실행 순서에 따라 예상치 못한 결과가 나오는 현상</b>을 말합니다.<br>

  레이스 컨디션의 가장 큰 문제는 항상 발생하는 것이 아니라 타이밍에 따라 간헐적으로 발생한다는 점으로, 찾기도 어렵고 재현하기도 힘들어서 멀티 스레드 환경에서 가장 조심해야하는 부분입니다.
</details>

<details>
  <summary>교착상태에 대해 설명해주세요.</summary><br>

  교착상태(Deadlock)란 <b>두 개 이상의 프로세스나 스레드가 서로가 가진 자원을 기다리면서 무한정 대기하는 상태</b>를 말합니다.<br>

  교착 상태는 프로세스나 스레드가 서로 자원을 점유하려고 하는 과정에서 아래 네 가지 필요조건이 동시에 충족될 경우 발생합니다.
  - <b>상호배제</b>: 자원은 한 번에 하나의 프로세스만 사용할 수 있다.
  - <b>비선점</b>: 다른 프로세스의 자원을 강제로 빼앗을 수 없다.
  - <b>점유와 대기</b>: 자원을 할당받은 상태에서 또 다른 자원을 기다리는 상태
  - <b>순환 대기</b>: 프로세스들이 원형으로 서로의 자원을 기다리는 상태

  교착상태를 해결하기 위한 방법으로는 크게 3가지가 있습니다.
  - <b>교착상태 예방</b>: 교착상태가 발생하는 조건 중 하나라도 충족하지 않도록 설계하는 방법
  - <b>교착상태 회피</b>: 교착 상태가 발생할 가능성을 배제하지 않고 자원을 적당히 할당하다가 교착상태의 위험이 있을 때에는 자원을 할당하지 않는 방법. 즉, 안전한 상태에서만 자원을 할당하는 방법으로, 대표적으로는 <b>은행원 알고리즘(Banker's Algorithm)</b>이 있다.
  - <b>검출 후 회복</b>: 자원을 제약 없이 할당하다가 교착상태가 발생하면 해결하는 방법
</details>

<details>
  <summary>가상 메모리에 대해 설명해주세요.</summary><br>

  가상 메모리란 <b>실행하고자 하는 프로그램의 일부만 메모리에 적재하는 메모리 관리 기법</b>입니다.<br>

  이를 통해 실제 메모리 크기보다 큰 프로그램도 실행할 수 있고, 여러 프로세스가 메모리를 효율적으로 공유할 수 있습니다.<br>

  주로 프로세스의 논리 주소 공간과 메모리의 물리 주소 공간을 페이지와 프레임이라고 하는 일정한 단위로 나누어서 관리하는 <b>페이징 기법</b>을 사용하여 구현하며, 운영체제는 물리 메모리와 디스크 간에 페이지를 교체하면서 가상 메모리 시스템을 구현합니다.<br>

  이때 보편적으로 사용되는 페이지 교체 알고리즘은 <b>LRU(Least Recently Used)</b> 알고리즘으로, 이는 실제 메모리 상의 페이지들 중에서 가장 오랫동안 사용되지 않은 페이지를 교체하는 방식입니다.

  > <b>논리 주소와 물리 주소</b><br>
  > 논리 주소와 물리 주소는 메모리 관리 측면에서 사용되는 두 가지의 다른 주소 체계입니다.<br>
  > <b>논리 주소(가상 주소)</b>는 프로세스가 바라보는 논리적인 주소로, 프로세스 입장에서는 항상 0번지부터 시작하는 연속된 메모리 공간을 가진 것처럼 보입니다.<br>
  > <b>물리 주소</b>는 하드웨어가 실제로 접근하는 메모리의 물리적인 주소를 말합니다.<br>
  > CPU는 논리 주소로 메모리에 접근하며, 이 논리 주소는 <b>MMU(Memory Management Unit)</b>에 의해 물리 주소로 변환되어 실제 메모리 주소에 접근하게 됩니다.

  > <b>페이지 폴트(Page Fault)</b><br>
  > 페이지 폴트란 <b>프로세스가 접근하려는 페이지가 가상 메모리에는 존재하지만, 물리 메모리에는 존재하는 않을 때 발생하는 예외 상황</b>을 말합니다.<br>
  > 페이지 폴트가 발생하면 운영체제는 디스크에서 해당 페이지를 찾아서 메모리로 가져오는 과정을 거치게 되며, 이때 디스크 I/O가 발생하므로 페이지 폴트가 자주 발생하는 경우 시스템 성능이 크게 떨어질 수 있습니다.
</details>

<details>
  <summary>캐시에 대해 설명해주세요.</summary><br>

  캐시(Cache)란 <b>자주 사용되는 데이터를 가까운 저장소에 임시로 보관해서 시스템의 성능을 향상시키는 기법</b>입니다.<br>

  캐시 저장소는 CPU와 가깝기 때문에 메모리나 디스크에서 데이터를 읽는 것보다 훨씬 빨라, 자주 사용하는 데이터의 경우에는 캐시에 이를 저장하고 읽는 방식으로 성능을 높일 수 있습니다.<br>

  캐시에 저장될 데이터는 아래와 같은 기준에 따라 결정됩니다.
  - <b>시간 지역성</b>: 어떤 데이터가 최근에 사용되었다면, 가까운 미래에 다시 사용될 가능성이 높다는 원리
  - <b>공간 지역성</b>: 특정 데이터에 접근할 때, 그 데이터와 메모리상에서 인접한 다른 데이터도 함께 접근될 가능성이 높다는 원리
</details>

#### 네트워크

<details>
  <summary>OSI 7 계층에 대해 설명해주세요.</summary><br>

  OSI 7 계층은 네트워크 통신 과정을 7개의 단계로 나누어서 표준화한 네트워크 참조 모델입니다.<br>

  <b>1계층은 물리 계층(Physical Layer)</b>으로, 0과 1의 비트를 전기 신호로 변환하여 전송하는 계층입니다.<br>
  물리 계층에는 주소 개념이 없으며 송수신만 이루어질 뿐 전송되는 데이터에 대해 어떠한 조작이나 판단도 하지 않습니다.<br>
  케이블, 허브, 리피터 같은 물리적 장비들이 여기에 해당합니다.<br>

  <b>2계층은 데이터 링크 계층(Data Link Layer)</b>으로, 같은 네트워크(LAN) 내에 있는 호스트 간의 데이터 전송을 담당합니다.<br>
  데이터링크 계층에는 주소 개념이 있으며, MAC 주소를 사용해서 프레임 단위로 데이터를 전송합니다. 스위치, 브리지가 이 계층에서 동작합니다.<br>
  
  <b>3계층은 네트워크 계층(Network Layer)</b>으로, LAN을 넘어서 서로 다른 네트워크 간의 경로를 찾아 통신할 수 있도록 하는 계층입니다.<br>
  여기에서는 IP 주소를 사용해서 패킷을 목적지까지 라우팅하며, 라우터가 이 계층에서 작동하고, 대표적인 프로토콜로 IP 프로토콜, ARP 프로토콜이 있습니다.<br>
  
  <b>4계층은 전송 계층(Transport Layer)</b>으로, 애플리케이션 간 데이터 전송을 담당합니다.<br>
  포트 번호를 사용해서 네트워크 상의 애플리케이션을 식별하여 어디에 데이터를 전달할지 결정하며, TCP와 UDP가 이 계층의 대표적인 프로토콜입니다. <br>
  
  <b>5계층은 세션 계층(Session Layer)</b>으로, 애플리케이션 간의 통신에서 세션을 관리하는 계층이며, 연결 설정, 유지, 종료 및 동기화 기능을 제공합니다.<br>
  
  <b>6계층은 표현 계층(Presentation Layer)</b>으로, 애플리케이션 간의 통신에서 메시지 포맷을 관리하는 계층이며, 암호화, 압축, 인코딩 같은 작업을 수행합니다.
  
  <b>7계층은 응용 계층(Application Layer)</b>으로, 사용자와 직접 상호작용하는 계층이며, 애플리케이션 목적에 맞는 통신 방법을 제공합니다. HTTP, FTP, SMTP, DNS 같은 프로토콜들이 이 계층에서 동작합니다.<br>
  
  이렇계 네트워크를 설계하면, 각 계층이 독립적으로 동작하여 하나의 계층에 문제가 생겨도 다른 계층에 영향을 주지 않고, 네트워크 문제가 발생했을 때 이를 체계적으로 분석할 수 있습니다.
</details>

<details>
  <summary>TCP와 UDP에 대해 설명해주세요.</summary><br>

  TCP와 UDP는 전송 계층에서 사용되는 두 가지 프로토콜로, <b>데이터 전송 방식</b>에서 차이가 있습니다.<br>

  <b>TCP(Transmission Control Protocol)</b>는 <b>연결 지향적 프로토콜</b>로, 데이터를 전송하기 전에 먼저 연결을 설정합니다.<br>
  TCP는 3-way handshake를 통해 연결을 맺고, 4-way handshake로 연결을 종료합니다.<br>
  TCP의 가장 큰 특징은 신뢰성으로, 데이터가 순차적으로 전달되는 것을 보장하고, 오류 제어 기능을 통해 패킷이 손실되면 재전송하여 모든 데이터가 정확하게 도작하도록 보장합니다. 또한 흐름 제어와 혼잡 제어 기능을 통해 네트워크 상황에 맞게 전송 속도를 조절할 수 있습니다.<br>

  <b>UDP(User Datagram Protocol)</b>는 <b>비연결 지향적 프로토콜</b>로, 연결 설정 과정 없이 바로 데이터를 전송합니다.<br>
  때문에 속도가 빠르고 오버헤드가 적지만, 신뢰성은 보장하지 않습니다. 즉, 패킷이 순서대로 도착하지 않을 수 있고, 손실될 수도 있습니다.<br>

  따라서 TCP는 이메일, 파일 전송처럼 데이터의 정확성이 중요한 곳에 주로 사용되고, UDP는 실시간 게임이나 동영상 스트리밍처럼 속도가 중요하고 약산의 손실은 허용할 수 있는 경우에 주로 사용됩니다.
</details>

<details>
  <summary>TCP의 3-way handshake, 4-way handshake에 대해 설명해주세요.</summary><br>

  <b>3-way handshake</b>는 TCP 통신에서 데이터를 전송하기 전에 클라이언트와 서버가 연결을 수립하는 과정으로, 아래 세 단계를 거칩니다.
  1. 클라이언트가 서버에게 연결 요청의 의미로 `SYN` 세그먼트를 전송합니다.
  2. 서버는 연결 요청에 대한 확인의 의미로 `SYN-ACK` 세그먼트를 응답합니다.
  3. 클라이언트는 서버의 응답에 대한 확인의 의미로 `ACK` 세그먼트를 서버로 보내며 최종적으로 연결이 수립됩니다.

  <b>4-way handshake</b>는 TCP 통신에서 연결을 종료하는 과정으로, 아래 네 단계를 거칩니다.
  1. 클라이언트가 서버에게 연결 종료 요청의 의미로 `FIN` 세그먼트를 전송합니다.
  2. 서버는 종료 요청에 대한 확인의 의미로 `ACK` 세그먼트를 클라이언트에게 응답합니다. (서버에서 아직 보낼 데이터가 남아있는 경우에도 `ACK` 세그먼트를 선응답합니다.)
  3. 서버는 모든 데이터 전송을 마친 후 서버쪽 연결 종료의 의미로 `FIN` 세그먼트를 클라이언트에게 전송합니다.
  4. 클라이언트는 서버쪽 연결 종료 확인의 의미로 `ACK` 세그먼트를 서버로 보내며 최종적으로 연결이 종료됩니다.
</details>

<details>
  <summary>HTTP와 HTTPS의 차이에 대해 설명해주세요.</summary><br>

  HTTP와 HTTPS는 웹에서 데이터를 주고받기 위한 프로토콜이며, <b>보안적인 측면</b>에서 차이가 있습니다.<br>

  <b>HTTP</b>는 애플리케이션 레벨의 요청-응답 기반 프로토콜로, 상태를 유지하지 않는 Stateless 프로토콜이며, TCP/IP 위에서 동작합니다.<br>
  평문 데이터를 전송하는 프로토콜이므로 클라이언트와 서버 간에 주고받는 모든 정보가 그대로 노출되어 보안에 취약합니다.<br>

  <b>HTTPS</b>는 HTTP에 <b>SSL/TLS 보안 계층</b>을 추가한 프로토콜로, 모든 데이터가 암호화되어 전송됩니다. 따라서 HTTP와 달리 중간에 가로채로 그 내용을 알 수 없습니다.
</details>

<details>
  <summary>SSL/TLS handshake에 대해 설명해주세요.</summary><br>

  SSL/TLS handshake는 클라이언트와 서버가 보안 연결을 설정하는 과정입니다.<br>
  1. 클라이언트가 서버에게 연결 요청을 보내면서 자신이 지원하는 TLS 버전, 사용 가능한 암호화 알고리즘 목록, 키 생성에 필요한 난수 등을 전송합니다.
  2. 서버는 클라이언트가 제안한 암호화 방식 중 하나를 선택하여 응답하고, 이후 서버의 공개키와 인증기관(CA, Certificate Authority)의 서명이 들어있는 인증서를 클라이언트에게 전송합니다.
  3. 클라이언트는 서버로부터 전달받은 인증서가 신뢰할 수 있는 인증서인지 검증합니다. 인증서는 CA의 개인키로 서명되어 있고, 클라이언트는 이를 운영체제나 브라우저에 미리 내장되어 있는 CA의 공개키를 통해 검증합니다.
  4. 이후 클라이언트는 서버의 공개키를 통해 통신에 사용할 비밀키를 암호화하여 서버에 전송하고, 서버는 이를 개인키로 확인합니다.
  5. 클라이언트와 서버 모두 비밀키와 난수를 조합하여 대칭키를 생성하고, 이후에 이루어지는 모든 통신은 이 대칭키로 암호화하여 전송합니다.

  > <b>SSL/TLS handshake에서 대칭키 암호화와 공개키 암호화를 복합적으로 사용하는 이유</b><br>
  > 대칭키 암호화와 공개키 암호화 방식을 복합적으로 활용하는 키를 <b>세션키</b>라고 합니다.<br>
  > 이를 통해 대칭키 암호화 방식의 보안 문제와, 공개키 암호화 방식의 성능 문제를 해결하고 각각의 장점만을 활용한 암호화 통신이 가능합니다.
</details>

<details>
  <summary><a>https://www.google.com</a>에 접속할 때 일어나는 일에 대해 설명해주세요.</summary><br>

  먼저 브라우저가 URL을 파싱해서 프로토콜과 도메인을 파악합니다.<br>

  이후 DNS 조회 과정이 일어나는데, `www.google.com`이라는 도메인 이름을 실제 IP 주소로 변환하기 위해 브라우저 캐시부터 시작해서 시스템 캐시, 로컬 DNS 서버를 거쳐서 최종적으로 IP 주소를 찾아냅니다.<br>

  IP 주소를 알아내면 3-way handshake 과정을 통해 해당 서버의 443번 포트와 TCP 연결을 설정하며, 추가로 HTTPS이기 때문에 보안 연결을 위한 TLS handshake를 진행하는데, 이때 암호화 방식을 협상하고 서버 인증서를 확인해서 보안 연결을 설정합니다.<br>

  보안 연결이 완료되면 HTTP 요청 메시지가 서버에 전송되며, 서버는 이에 대한 HTTP 응답 메시지를 내려줍니다.<br>

  서버로부터 전달된 HTTP 응답 메시지는 브라우저에서 받아서 최종적으로 화면에 렌더링 합니다.
</details>

<details>
  <summary>HTTP 메서드의 종류와 이것이 하는 역할에 대해 설명해주세요.</summary><br>

  HTTP 메서드는 <b>클라이언트가 서버에게 어떤 동작을 요청할지를 나타내는 방법</b>입니다.<br>

  <b>GET</b>은 서버로부터 리소스를 조회할 때 사용하며, 데이터를 가져오기만 하고 서버의 상태를 변경하지는 않습니다.<br>

  <b>POST</b>는 서버에 새로운 리소스를 생성할 때 주로 사용합니다.<br>

  <b>PUT</b>은 서버에 존재하는 리소스를 수정하거나 존재하지 않으면 생성합니다. 특정 리소스에 대한 전체 데이터를 새로운 내용으로 교체할 때 사용합니다.<br>

  <b>PATCH</b>는 특정 리소스의 일부분만을 수정할 때 사용합니다. PUT과 달리 전체가 아닌 특정 필드만 업데이트 하는 경우에 사용합니다.<br>

  <b>DELETE</b>는 서버의 리소스를 삭제할 때 사용합니다.<br>

  <b>HEAD</b>는 GET과 비슷하지만 응답 바디 없이 헤더 정보만 가져올 때 사용합니다.<br>

  <b>OPTIONS</b>는 서버가 특정 리소스에 대해 어떤 메서드들을 지원하는지 확인할 때 사용합니다.
</details>

<details>
  <summary>GET과 POST의 차이에 대해 설명해주세요.</summary><br>

  GET은 URL에 데이터가 노출되지만 POST는 요청 바디에 숨겨져서 전송된다는 차이가 있으며, 때문에 보안적인 측면에서 POST가 상대적으로 안전합니다.<br>
  
  또한 GET 요청에 대한 응답은 브라우저에 자동으로 캐싱되어, 같은 URL 요청 시 캐싱된 데이터를 사용할 수 있지만, POST 요청은 보통 서버의 상태를 변경하는 작업이기 때문에 브라우저가 기본적으로 캐싱하지 않아서 같은 URL 요청도 매번 새로운 요청을 보낸다는 차이가 있습니다.
</details>

<details>
  <summary>HTTP 상태 코드에 대해 설명해주세요.</summary><br>

  HTTP 상태 코드는 <b>클라이언트의 요청에 대한 서버의 응답 상태를 나타내는 3자리 숫자 코드</b>이며, 첫 번째 자리 숫자에 따라 5개의 그룹으로 나뉩니다.<br>

  <b>100번대</b>는 <b>정보성 응답</b>으로, 요청이 수신되어 처리 중임을 나타냅니다.<br>

  <b>200번대</b>는 <b>성공 응답</b>으로, 요청이 성공적으로 처리되었음을 의미합니다.<br>

  <b>300번대</b>는 <b>리다이렉션 응답</b>으로, 클라이언트가 요청한 리소스가 이동된 경우 이를 알리기 위한 코드입니다.<br>

  <b>400번대</b>는 <b>클라이언트 오류에 대한 응답</b>으로, 클라이언트 측의 잘못된 요청으로 인해 오류가 발생했음을 의미합니다.<br>

  <b>500번대</b>는 <b>서버 오류에 대한 응답</b>으로, 명백히 올바른 요청에 대해 서버 내부에서 오류가 발생했음을 의미합니다.
</details>

#### 자료구조/알고리즘

<details>
  <summary>스택과 큐에 대해 설명해주세요.</summary><br>

  <b>스택(Stack)</b>은 LIFO(Last In First Out) 구조로, 마지막에 들어온 데이터가 가장 먼저 나가는 방식의 자료구조입니다.<br>
  주로 함수 호출 관리, 브라우저의 뒤로가기 기능, 수식의 괄호 검사, DFS 알고리즘 등에서 사용하며, 시간 복잡도는 모든 기본 연산이 O(1)입니다.<br>

  <b>큐(Queue)</b>는 FIFO(First In First Out) 구조로, 먼저 들어온 데이터가 먼저 나가는 방식의 자료구조입니다.<br>
  주로 프로세스 스케줄링, I/O 작업 대기열, BFS 알고리즘, 버퍼링 등에 사용되며, 시간 복잡도는 모든 기본 연산이 O(1)입니다.
</details>

<details>
  <summary>트리와 힙에 대해 설명해주세요.</summary><br>

  <b>트리(Tree)</b>는 계층적 구조를 가진 비선형 자료구조로, 노드들이 부모-자식 관계로 연결되어 있습니다.<br>
  최상위 루트 노드부터 시작해서 각 노드가 여러 자식 노드를 가질 수 있으며, 사이클이 존재하지 않습니다.<br>
  주로 파일 시스템, DOM 구조, 의사결정 트리 등과 같이 계층적 데이터 표현이 필요한 경우에 사용됩니다.<br>

  <b>힙(Heap)</b>은 완전 이진 트리 기반의 자료구조로, 부모와 자식 간에 특정한 순서 관계를 만족합니다.<br>
  <b>최대힙</b>은 부모 노드의 값이 자식 노드의 값보다 항상 크거나 같고, <b>최소힙</b>은 부모 노드의 값이 자식 노드의 값보다 항상 작거나 같습니다.<br>
  힙의 핵심 특징은 루트 노드가 최대힙에서는 항상 최댓값을 의미하고, 최소힙에서는 항상 최솟값을 의미한다는 점이며, 이러한 특징 때문에 주로 최댓값/최솟값을 빠르게 찾아야 하는 상황에서 유용하게 사용됩니다.<br>
  힙은 새로운 노드의 삽입과 삭제 시 힙의 속성을 유지하기 위해 heapify 과정을 거치며, 이때의 시간 복잡도는 O(log n)입니다.

  > <b>완전 이진 트리(Complete Binary Tree)</b><br>
  > 완전 이진 트리는 다음 두 가지 조건을 충족하는 트리를 의미합니다.<br>
  > 첫째, 마지막 레벨을 제외하고 모든 노드가 채워져 있어야 합니다. 마지막 레벨의 노드는 다 채워져 있을 수도 있고 아닐 수도 있습니다.<br>
  > 둘째, 노드는 왼쪽에서 오른쪽 방향으로 채워져야 합니다.
</details>

<details>
  <summary>배열과 연결 리스트의 차이에 대해 설명해주세요.</summary><br>

  <b>배열(Array)</b>은 메모리상에서 연속적인 공간에 동일한 타입의 데이터를 저장하는 자료구조입니다.<br>
  인덱스를 통해 직접 접근이 가능하여 임의 접근(Random Access)이 O(1) 시간에 이루어집니다.<br>
  장점으로는 빠른 접근 속도와 메모리 효율성이 있고, 단점으로는 크기가 고정되어 있어 동적 할당이 어렵고, 중간 삽입/삭제 시 O(n)의 시간이 소요됩니다.<br>

  <b>연결 리스트(Linked List)</b>는 노드들이 포인터로 연결된 자료구조입니다.<br>
  각 노드는 데이터와 다음 노드를 가리키는 포인터를 가지고 있어, 메모리상에서 연속적이지 않은 위치에 저장될 수 있습니다.<br>
  장점은 동적으로 크기 조절이 가능하고, 삽입/삭제가 O(1) 시간에 가능하다는 점이며, 단점으로는 순차 접근(Sequential Access)만 가능하여 특정 위치에 접근하려면 O(n) 시간이 걸리고, 포인터를 위한 추가적인 메모리가 필요하다는 점이 있습니다.<br>
  
  핵심 차이점은 <b>메모리 구조(연속 vs 비연속)</b>, <b>접근 방식(임의 vs 순차)</b>, <b>크기 변경 가능성</b>, 그리고 <b>삽입/삭제와 접근의 시간복잡도 트레이드오프</b>입니다.<br>
  빈번한 접근이 필요하면 배열을, 빈번한 삽입/삭제가 필요하면 연결 리스트를 선택하는 것이 일반적입니다.
</details>

<details>
  <summary>해시 테이블에 대해 설명해주세요.</summary><br>

  <b>해시 테이블(Hash Table)</b>은 <b>키-값(Key-Value) 쌍으로 데이터를 저장하는 자료구조</b>로, <b>해시 함수</b>를 사용해서 키를 버킷(Bucket)의 인덱스(Index)로 변환하여 데이터에 빠르게 접근할 수 있도록 합니다.<br>

  이상적인 경우 삽입, 삭제, 검색 모두 O(1)의 시간이 소요됩니다. 하지만 <b>해시 충돌</b>이 많이 발생하면 최악의 경우 O(n)까지 늘어날 수 있습니다.<br>

  해시 충돌은 서로 다른 키가 같은 해시값을 가지는 경우에 발생하며, 이를 해결하기 위해서는 같은 인덱스에 연결 리스트로 여러 값을 저장하는 <b>체이닝 방식</b>을 사용하거나, 다른 빈 공간을 찾아서 저장하는 <b>개방 주소법</b>을 사용하여 해결할 수 있습니다.<br>

  해시 테이블은 데이터베이스 인덱싱, 프로그래밍 언어의 Dictionary나 Map 자료형 등에 사용됩니다.
</details>

<details>
  <summary>우선순위 큐에 대해 설명해주세요.</summary><br>

  <b>우선순위 큐(Priority Queue)</b>는 각 원소에 우선순위가 있어서, <b>들어온 순서와 관계없이 우선순위가 높은 원소가 먼저 처리되는 자료구조</b>입니다.<br>
  즉, 우선순위가 가장 높은 데이터를 먼저 꺼내기 위해 고안된 자료구조로, 이를 구현하기 위해서는 일반적으로 <b>힙(Heap)</b>을 사용합니다.<br>

  힙은 <b>완전 이진 트리</b>를 기반으로 구현되었기 때문에 우선순위 큐를 힙으로 구현하면 삽입과 삭제가 모두 <b>O(log n)</b> 시간에 처리할 수 있습니다.<br>
  배열이나 연결 리스트로도 구현 가능하지만 이 둘은 선형 자료구조이며, 삽입 또는 삭제 연산을 위한 시간 복잡도가 O(n)이므로, 비효율적입니다.<br>

  우선순위 큐는 운영체제의 프로세스 스케줄링, 최단 경로 알고리즘 등에서 주로 사용됩니다.
</details>

<details>
  <summary>이진 탐색 트리에 대해 설명해주세요.</summary><br>

  <b>이진 탐색 트리(Binary Search Tree)</b>는 이진 트리 구조에서 <b>특별한 규칙</b>이 추가된 자료구조입니다.<br>

  이진 탐색 트리에서 <b>각 노드의 왼쪽 자식은 현재 노드보다 작은 값, 오른쪽 자식은 현재 노드보다 큰 값</b>을 가지며, 이 규칙은 모든 노드에 적용됩니다.<br>

  시간 복잡도는 균형 잡힌 트리에서는 O(log n)이지만, 노드가 한쪽으로 치우친 형태이면 최악의 경우 O(n)까지 늘어날 수 있습니다.
</details>

<details>
  <summary>RB 트리에 대해 설명해주세요.</summary><br>

  <b>RB(Red-Black)</b> 트리는 <b>자가 균형 이진 탐색 트리</b>의 한 종류로, BST의 문제점인 <b>편향된 트리</b>를 해결하기 위해 각 노드에 색깔(빨간색 또는 검은색)을 부여하고, “루트 노드와 리프 노드는 항상 검은색이어야 한다”, “빨간색 노드의 자식은 반드시 검은색이어야 한다”와 같은 특별한 규칙들을 적용한 자료구조입니다.<br>

  RB 트리는 이러한 규칙을 깨지 않기 위해 삽입이나 삭제 시에 색깔 변경이나 회전 연산을 통해 다시 균형을 맞추며, 트리의 높이가 항상 균형되도록 유지합니다.
</details>

<details>
  <summary>Big-O 표기법의 시간 복잡도 크기 순서를 말해주세요.</summary><br>

  O(1) < O(log N) < O(N) < O(N log N) < O(N^2) < O(2^N) < O(N!)
</details>

<details>
  <summary>주요 정렬 방식에 대해 설명해주세요.</summary><br>

  <b>버블 정렬</b>은 첫 번째 요소부터 마지막 요소까지 순회하며, 서로 인접한 두 원소를 비교해가며 정렬하는 알고리즘으로, 가장 간단하지만 <b>O(n²)</b>의 시간복잡도로 비효율적입니다. 따라서 실제로는 거의 사용하지 않습니다.

  <b>선택 정렬</b>은 매번 최솟값을 찾아서 앞쪽에 배치하는 방식으로, 역시 <b>O(n²)</b>의 시간복잡도를 갖지만 교환 횟수가 적어 메모리 쓰기가 비싼 환경에서는 고려해볼 수 있는 정렬 방식입니다.
  
  <b>삽입 정렬</b>은 두 번째 요소부터 시작해서 그 앞에 존재하는 원소들과 비교하여 올바른 위치를 찾아 삽입하는 정렬 알고리즘입니다. 최악의 경우 <b>O(n²)</b>의 시간복잡도를 갖지만 거의 정렬된 데이터에 대해서는 <b>O(n)</b>에 가까워서 효율적입니다.
  
  <b>병합 정렬</b>은 주어진 배열을 크기가 1이 될 때까지 나누고 각각을 정렬한 후 합치는 <b>분할 정복 방식</b>에 기반한 정렬 알고리즘입니다. 항상 <b>O(n log n)</b>의 시간복잡도를 보장하고 안정 정렬이라는 장점이 있으나 추가 메모리가 필요하다는 단점이 있습니다.
  
  <b>퀵 정렬</b>은 피벗(Pivot)을 설정하고 피벗을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 분할하는 <b>분할 정복 방식</b>에 기반한 정렬 알고리즘입니다. 병합 정렬과 달리 리스트를 비균등하게 분할하며, 평균적으로 <b>O(n log n)</b>의 시간복잡도를 가지고, 제자리 정렬이 가능해서 널리 사용됩니다. 다만 최악의 경우 시간복잡도는 <b>O(n²)</b>이 될 수 있습니다.
  
  <b>힙 정렬</b>은 힙 자료구조를 이용한 정렬로, 주어진 데이터를 힙 자료구조로 만들어 최댓값 또는 최솟값부터 하나씩 꺼내서 정렬하는 알고리즘입니다. 항상 <b>O(n log n)</b>을 보장하고 제자리 정렬이 가능합니다. 하지만 불안정 정렬이고 실제로는 퀵 정렬보다 느린 경우가 많습니다.
</details>

<details>
  <summary>DFS와 BFS에 대해 설명해주세요.</summary><br>

  DFS와 BFS는 그래프나 트리를 탐색하는 두 가지 기본적인 알고리즘입니다.

  <b>DFS(Depth First Search)</b>는 한 방향으로 계속 깊게 들어가다가 더 이상 갈 곳이 없으면 뒤로 돌아와서 다른 경로를 탐색하는 방식입니다.<br>
  구현은 보통 재귀나 스택을 사용하며, 현재 노드를 방문 처리하고, 인접한 노드들을 하나씩 재귀 호출하는 식으로 구현합니다.<br>
  DFS는 메모리를 적게 사용하지만 최단 경로를 보장하지 않습니다.<br>
  
  <b>BFS(Breadth Fisrt Search)</b>는 현재 레벨의 모든 노드를 먼저 방문하고, 그 다음 레벨로 넘어가는 방식입니다.<br>
  이는 큐를 사용해서 구현하는데, 시작 노드를 큐에 넣고, 큐에서 하나씩 빼면서 그 노드의 인접 노드들을 다시 큐에 넣는 과정을 반복하는 식으로 구현합니다.<br>
  BFS는 DFS에 비해 메모리를 더 많이 사용하지만 최단 경로를 찾을 수 있습니다.<br>
  
  시간 복잡도는 둘 다 O(V + E)로 동일합니다.
</details>

---

### 🧬 Architecture

<details>
  <summary>MSA에 대해 설명해주세요.</summary><br>

  MSA(Microservices Architecture)란 <b>하나의 큰 애플리케이션을 여러 개의 작은 서비스로 나누어서 개발하고 운영하는 아키텍처 패턴</b>입니다.<br>

  이를 통해 서비스별로 독립적인 개발, 배포가 가능해서 전체 시스템을 중단하지 않고도 특정 기능만 업데이트할 수 있고, 특정 서비스에 장애가 발생했을 때 장애의 전파를 최소화할 수 있습니다.<br>
  
  단, 서비스 간 통신이 네트워크를 통해 이루어지기 때문에 네트워크 오버헤드 및 복잡도가 증가하고, 데이터의 일관성이 떨어지는 문제가 발생할 수 있습니다.
</details>

<details>
  <summary>MSA 환경에서 데이터의 일관성을 보장하는 방법에 대해 설명해주세요.</summary><br>

  <b>2PC(2-Phase-Commit)</b>는 분산 트랜잭션을 처리하기 위한 전통적인 방법으로, 트랜잭션의 전체적인 진행을 관리하는 코디네이터(Cordinator)와 트랜잭션을 처리하는데 참여하는 참여자(Participant)간에 소통하며 <b>준비 단계(Prepare Phase)</b>와 <b>커밋 단계(Commit Phase)</b>를 거쳐 데이터의 일관성을 보장하는 방법입니다.<br>

  <b>SAGA 패턴</b>은 약간의 일관성을 포기하고 Eventual Consistency(최종 일관성)를 보장하여 효율성을 높이기 위한 패턴입니다.<br>
  2PC에서는 여러 트랜잭션을 하나의 트랜잭션으로 묶어서 처리하지만, SAGA 패턴은 긴 트랜잭션을 여러 개의 짧은 로컬 트랜잭션으로 분리하여 처리합니다.<br>
  이때 각 트랜잭션은 다른 트랜잭션의 완료를 기다리지 않고 독립적으로 실행되며, 따라서 트랜잭션의 원자성을 보장하기 위해 만약 중간에 문제가 생길 경우에는 <b>보상 트랜잭션</b>이 실행되어 이전 트랜잭션을 롤백하는 것과 같은 효과를 가져옵니다.

  > <b>전통적인 ACID 일관성 vs SAGA의 최종 일관성</b><br>
  > 전통적인 ACID 트랜잭션에서는 <b>Strong Consistency(강한 일관성)</b>을 제공합니다. 즉, 트랜잭션이 완료되는 순간 모든 데이터가 일관된 상태를 유지하며, 하나의 작업이라도 실패하면 전체를 롤백하여 원래 상태로 되돌립니다.<br>
  > SAGA 패턴은 이와 다른 접근 방식을 사용합니다. SAGA 패턴에서는 각 트랜잭션이 독립적으로 실행되며 중간에 문제가 발생할 경우 이미 완료된 트랜잭션들을 대상으로 역순으로 보장 트랜잭션을 실행합니다. 때문에 이 과정에서 <b>일시적으로 불일치 상태</b>가 존재할 수 있습니다. 다만 보상 트랜잭션이 모두 완료된 시점에는 최종적으로 일관된 상태에 도달하기 때문에 SAGA 패턴은 <i>"약간의 일관성을 포기하고 최종 일관성을 보장한다"</i>라고 말할 수 있습니다.
</details>

<details>
  <summary>MVC 패턴에 대해 설명해주세요.</summary><br>

  MVC 패턴은 Model, View, Controller 세 개의 구성요소로 애플리케이션을 나누어 개발하는 디자인 패턴입니다.

  <b>Model</b>은 데이터와 비즈니스 로직을 담당합니다. 데이터베이스에서 데이터를 가져오거나 저장하고, 실제 업무 처리를 하는 부분입니다.

  <b>View</b>는 사용자에게 보여지는 화면, 즉 UI를 담당합니다. 사용자가 실제로 보고 상호작용하는 부분으로, 웹에서는 HTML, JSP 같은 것들이 여기에 해당합니다.

  <b>Controller</b>는 사용자의 요청을 받아서 처리하는 역할을 합니다. 사용자가 요청을 보냈을 때, Controller가 그 요청을 받아서 적절한 Model을 호출하고, 그 결과를 View에 전달해서 화면에 렌더링하게 됩니다.

  이렇게 나누는 이유는 각각의 역할을 분리해서 코드의 재사용성을 높이고 유지보수를 쉽게 하기 위해서입니다. 예를 들어 화면 디자인이 바뀌어도 Model이나 Controller는 건드릴 필요가 없고, 비즈니스 로직이 바뀌어도 View는 그대로 둘 수 있죠.

  Spring MVC에서는 `DispatcherServlet`이 Front Controller 역할을 하면서 모든 요청을 받아서 적절한 Controller에게 전달하는 방식으로 MVC 패턴을 구현하고 있습니다.
</details>

---

### 🧑‍💻 Programming Language

#### 공통

<details>
  <summary>객체지향 프로그래밍에 대해 설명해주세요.</summary><br>

  객체지향 프로그래밍은 <b>현실 세계의 사물들을 객체로 모델링해서 프로그램을 설계하고 구현하는 프로그래밍 패러다임</b>입니다.<br>

  기존의 절차지향 프로그래밍이 함수 중심으로 프로그램을 작성했다면, 객체지향은 관련된 속성과 기능을 캡슐화하는 <b>객체</b>를 중심으로 프로그램을 작성합니다.<br>

  객체지향은 코드의 재사용성이 높아지고, 유지보수가 쉬워지며, 현실 세계를 모델링하기 때문에 이해하기 쉽다는 장점이 있으나, 절차지향 프로그래밍에 비해 코드의 복잡성이 증가하고, 실행 속도가 느립니다.
</details>

<details>
  <summary>객체지향 프로그래밍의 4가지 특징에 대해 설명해주세요.</summary><br>

  <b>캡슐화(Encapsulation)</b>란 데이터와 그 데이터를 조작하는 메서드를 하나의 클래스로 묶고, 외부에서 직접 접근하지 못하도록 정보를 은닉하는 것입니다. 이를 통해 데이터의 무결성을 보장하고 외부 의존성을 줄일 수 있습니다.<br>

  <b>상속(Inheritance)</b>이란 기존 클래스의 속성과 메서드를 새로운 클래스가 물려받아 재사용하는 것입니다. 이를 통해 코드의 재사용성을 높이고 계층적 분류가 가능해집니다.<br>

  <b>다형성(Polymorphism)</b>이란 동일한 인터페이스나 부모 클래스 타입으로 서로 다른 객체들을 참조할 수 있고, 각 객체의 실제 타입에 따라 다른 동작을 수행하는 것입니다. 이를 통해 유연하고 확장 가능한 코드를 작성할 수 있습니다.<br>

  <b>추상화(Abstraction)</b>란 복잡한 구현 세부사항을 숨기고 중요한 특징만을 인터페이스나 추상 클래스로 제공하는 것입니다.
</details>

<details>
  <summary>객체지향 프로그래밍의 5대 원칙에 대해 설명해주세요.</summary><br>

  <b>단일 책임 원칙(SRP, Single Responsibility Principle)</b>이란 <b>하나의 클래스는 하나의 책임만 가져야 한다는 원칙</b>입니다. 즉, 하나의 클래스에 모든 기능을 부여하지 말고 목적과 취지에 맞게 속성과 메서드를 구성함으로써 하나의 책임만을 갖도록 해야함을 의미합니다.<br>

  <b>개방-폐쇄 원칙(OCP, Open-Closed Principle)</b>이란 <b>확장에는 열려있고 수정에는 닫혀있어야 한다는 원칙</b>입니다. 즉, 기존 코드를 변경하지 않고도 새로운 기능을 추가할 수 있어야 합니다. 이는 인터페이스나 추상 클래스를 활용해서 새로운 구현체를 추가하는 방식으로 달성할 수 있습니다.<br>
  
  <b>리스코프 치환 원칙(LSP, Liskov Substitution Principle)</b>이란 <b>상위 타입의 객체를 하위 타입의 객체로 치환해도 프로그램이 정상적으로 동작해야 한다는 원칙</b>입니다. 이는 인터페이스와 구현체 간의 관계, 부모 클래스와 자식 클래스 간의 관계를 얼마나 논리적으로 설계했느냐에 대한 원칙으로, 하위 클래스가 상위 클래스의 역할을 대신할 때 이것이 논리적으로 맞아 떨어져야 함을 의미합니다.</b>
  
  <b>인터페이스 분리 원칙(ISP, Interface Segregation Principle)</b>이란 <b>클라이언트는 자신이 사용하지 않는 메서드에 의존하면 안 된다는 원칙</b>입니다. 즉, 하나의 큰 인터페이스보다는 여러 개의 구체적인 인터페이스로 나누어서 상황에 맞는 메서드만 제공할 수 있도록 해야함을 의미합니다.<br>
  
  <b>의존성 역전 원칙(DIP, Dependency Inversion Principle)</b>이란 <b>고수준 모듈이 저수준 모듈에 의존하는 경우가 생기면 안 된다는 원칙</b>으로, 구체적인 구현체가 아니라 그 구현체가 구현하는 인터페이스나 추상 클래스에 의존하도록 설계함으로써 결합도를 낮추고 유연성을 높여야 함을 의미합니다.
</details>

<details>
  <summary>컴파일러와 인터프리터의 차이에 대해 설명해주세요.</summary><br>

  <b>컴파일러</b>는 소스 코드 전체를 <b>실행 전에 미리 기계어로 번역하는 방식</b>으로, 먼저 컴파일 과정을 거쳐 실행 파일을 만들고, 그 실행 파일을 직접 실행하는 방식입니다. C, C++ 같은 언어가 대표적입니다.<br>

  <b>인터프리터</b>는 소스 코드를 <b>실행 시점에 한 줄씩 읽어가며 즉시 해석하고 실행하는 방식</b>입니다. Python, JavaScript 같은 언어가 이 방식을 사용합니다.<br>

  <b>실행 속도</b> 면에서는 실행할 때마다 번역 과정을 거쳐야 하는 인터프리터 방식에 비해 이미 기계어로 변환되어 있어 CPU가 바로 실행할 수 있는 컴파일러가 훨씬 빠릅니다.<br>
  <b>개발 편의성</b> 면에서는 매번 컴파일 과정을 거쳐야하는 컴파일러에 비해 코드를 수정하면 바로 실행해볼 수 있는 인터프리터가 디버깅이나 테스트 하기가 편합니다.<br>
  또 컴파일러는 문법 오류를 컴파일 시점에 모두 잡아내지만, 인터프리터는 실행 중에 오류가 있는 줄에 도달해야 오류를 발견할 수 있다는 차이가 있습니다.
</details>

<details>
  <summary>프레임워크와 라이브러리의 차이에 대해 설명해주세요.</summary><br>

  프레임워크와 라이브러리의 가장 큰 차이점은 <b>제어의 주도권</b>이 어디에 있느냐입니다.<br>

  <b>라이브러리</b>는 개발자가 필요한 기능을 가져다 쓰기 위한 도구의 모음으로, 개발자가 언제, 어떻게 사용할지를 결정하고 직접 호출해서 사용합니다.<br>
  
  <b>프레임워크</b>는 개발자에게 전체적인 구조와 흐름을 제공하고, 개발자는 그 틀 안에서 구체적인 기능을 구현하는 방식으로, 프레임워크가 언제 개발자의 코드를 호출할지를 결정합니다.<br>
  
  즉, 라이브러리는 제어의 주도권이 <b>개발자</b>에게 있고, 프레임워크는 제어의 주도권이 <b>프레임워크</b>에게 있다는 차이가 있으며, 이러한 특성을 <b>IoC(Inversion of Control, 제어의 역전)</b>라고 부릅니다.
</details>

<details>
  <summary>Call By Value와 Call By Reference의 차이에 대해 설명해주세요.</summary><br>

  <b>Call By Value(값에 의한 호출)</b>는 <b>메서드를 호출할 때 실제 값의 복사본을 전달하는 방식</b>입니다. 원본 변수의 값을 복사해서 매개변수에 전달하기 때문에, 메서드 내에서 매개변수 값을 변경해도 원본 변수에는 영향을 주지 않습니다.<br>

  <b>Call By Reference(참조에 의한 호출)</b>는 <b>메서드를 호출할 때 변수의 메모리 주소를 직접 전달하는 방식</b>입니다. 원본 변수의 주소를 전달하기 때문에, 메서드 내에서 매개변수를 통해 값을 변경하면 원본 변수의 값도 함께 변경됩니다.
</details>

<details>
  <summary>TDD에 대해 설명해주세요.</summary><br>

  TDD(Test Driven Development)란 일반적인 개발 방식과는 다르게 <b>테스트를 먼저 작성하고 그 테스트를 통과하는 코드를 나중에 구현하는 개발 방법론</b>입니다.<br>

  TDD는 <b>Red-Green-Refactor</b>라는 3단계 사이클로 진행됩니다.
  - <b>Red 단계</b>에서는 개발할 기능 또는 모듈에 대한 테스트 케이스를 작성합니다. 아직 구현되지 않은 기능에 대한 테스트이기 때문에 당연히 실패합니다.
  - <b>Green 단계</b>에서는 테스트를 통과시키기 위한 최소한의 코드를 작성합니다. 완벽한 코드가 아니라 일단 테스트만 통과하면 됩니다.
  - <b>Refactor 단계</b>에서는 테스트가 통과하는 상태를 유지하면서 중복 제거, 구조 개선 등을 통해 Green 단계에서 작성했던 코드를 개선합니다.
  
  TDD의 장점은 버그를 조기에 발견할 수 있고, 안정성을 향상시킬 수 있으며, 테스트를 먼저 작성하다 보니 자연스럽게 요구사항을 명확히 하게 되고, 설계에 대해 더 깊이 생각하게 됩니다. 하지만 초기 개발 속도가 느려질 수 있고, 테스트 코드 자체도 유지보수 범위에 포함된다는 단점이 있습니다.
</details>

<details>
  <summary>DDD에 대해 설명해주세요.</summary><br>

  DDD(Domain Driven Design)란 <b>도메인을 중심으로 프로그램을 설계하는 개발 방법론</b>입니다. 즉, 기술적인 구현보다는 <b>비즈니스 도메인을 먼저 정확히 이해하고 그것을 코드로 표현하는 데 집중</b>하자는 것입니다.<br>

  여기서 <b>도메인</b>이라는 것은 소프트웨어가 해결하려는 문제 영역, 즉 <b>비즈니스 영역</b>을 말합니다. 예를 들어 쇼핑몰이라면 주문, 결제, 배송 같은 것들이 도메인이 되는 거죠.<br>
  
  DDD의 장점은 유비쿼터스 언어, 바운디드 컨텍스트와 같은 개념을 사용함으로써 비즈니스 요구사항 변화에 유연하게 대응할 수 있고, 도메인 전문가와 개발자 간의 소통이 원활해진다는 점입니다.<br>
  
  단, 학습 곡선이 높고, 작은 프로젝트에 적용하기에는 오버엔지니어링이 될 수 있어서 복잡한 비즈니스 도메인을 가진 대규모 프로젝트에서 주로 사용됩니다.

  > <b>유비쿼터스 언어</b><br>
  > 유비쿼터스 언어란 특정 도메인에서 특정 용어가 해당 도메인에서의 의도를 명확히 반영하고, 도메인의 핵심 개념을 잘 전달할 수 있는 언어를 말합니다.<br>
  > 즉, <b>모든 팀원이 특정 용어를 들었을 때 같은 것을 생각할 수 있도록 명확하게 정의된 언어</b>로, 이를 통해 코드의 가독성을 높이고 코드를 분석하고 이해하는 시간을 절약할 수 있습니다.<br>

  > <b> 바운디드 컨텍스트</b><br>
  > 바운디드 컨텍스트(Bounded Context)란 <b>특정 도메인 모델에 대한 유비쿼터스 언어가 동일한 의미를 갖는 명시적인 경계</b>를 의미합니다.<br>
  > 이는 복잡한 시스템을 여러 개의 독립적이고 관리 가능한 부분으로 나누는 방법으로, 각 컨텍스트 내에서만 유효한 용어와 개념을 정의하여 모호성을 줄이고 일관된 모델을 유지하는 방법입니다.<br>
  > 예를 들어, '고객'이라는 도메인은 결제 도메인 입장에서는 신용카드 정보나 계좌 정보 등을 가진 '결제자'를 의미하고, 배송 도메인 입장에서는 상품을 받을 주소와 우편번호, 전화번호 등을 가진 '수취자'를 의미하기 때문에, 각 도메인마다 별도의 바운디드 컨텍스트를 두고 해당 컨텍스트에 맞는 모델을 정의해야 합니다.
</details>

<details>
  <summary>VO와 DTO, BO, DAO에 대해 설명해주세요.</summary><br>

  <b>VO(Value Object)</b>는 값 자체를 표현하는 객체입니다. 한 번 생성되면 변경할 수 없는 불변 객체이고, 값이 같으면 같은 객체로 취급됩니다. 주로 도메인 모델에서 특정 값을 나타낼 때 사용합니다.<br>

  <b>DTO(Data Transfer Object)</b>는 계층 간 데이터 전송을 위한 객체입니다. 주로 컨트롤러와 서비스 계층 사이, 또는 API 응답에서 사용됩니다. 비즈니스 로직은 없고 데이터를 담아서 전달하는 역할만 합니다.<br>
  
  <b>BO(Business Object)</b>는 비즈니스 로직을 포함하는 객체입니다. 실제 업무 규칙과 처리 로직이 들어있어서 도메인의 핵심 기능을 담당합니다.<br>
  
  <b>DAO(Data Access Object)</b>는 데이터베이스 접근을 담당하는 객체입니다. CRUD 연산을 수행하는 메소드들을 가지고 있고, 비즈니스 로직과 데이터 접근 로직을 분리하는 역할을 합니다.
</details>

#### Java

<details>
  <summary>Java의 특징에 대해 설명해주세요.</summary><br>

  자바는 JVM만 설치되어 있다면 자바 컴파일러가 컴파일 한 바이트코드를 JVM에서 각 플랫폼(운영체제)에 맞게 이를 해석하여 실행하기 때문에 어떤 운영체제건 동일하게 실행된다는 <b>플랫폼 독립성</b>의 특징을 갖고 있습니다.<br>

  또한 <b>객체지향 프로그래밍</b>을 완전히 지원하여 캡슐화, 상속, 다형성, 추상화를 모두 구현할 수 있어 코드의 재사용성과 유지보수성이 뛰어납니다.<br>

  또 <b>가비지 컬렉터</b>를 통해 자동으로 메모리 관리를 해주어 개발자가 메모리 관리에 들이는 비용이 적으며, <b>강한 타입 체크</b>를 통해 컴파일 타임에 대부분의 오류를 잡아낼 수 있습니다.
</details>

<details>
  <summary>Java는 컴파일러와 인터프리터 방식 중 어떤 방식을 사용하나요?</summary><br>

  Java는 <b>컴파일러와 인터프리터 방식을 혼합해서 사용</b>합니다.<br>

  자바 코드가 실행되는 과정을 살펴보면 다음과 같습니다.
  - 먼저 자바 소스 코드가 <b>컴파일러</b>에 의해 바이트 코드로 컴파일 되며, 이 과정에서 문법 오류나 타입 체크 등의 정적 검사가 이루어집니다.
  - 이후 JVM의 클래스 로더에서 컴파일 된 바이트 코드를 JVM 메모리에 적재한 후 실행 엔진에서 이를 해석하고 실행하는데, 이때 기본적으로 <b>인터프리터</b> 방식을 사용하여 바이트코드를 한 줄씩 읽어서 해석하고 실행하게 됩니다.
  - 단, 이때 성능 최적화를 위해 <b>JIT 컴파일러</b> 방식을 사용하여, 자주 실행되는 바이트 코드의 경우에는 해석한 네이티브 코드를 캐시해두었다가 이후에 다시 실행해야 할 때에는 해석하는 과정을 생략하고 캐싱되어 있는 네이티브 코드를 바로 실행하는 방식을 사용하기도 합니다.
</details>

<details>
  <summary>Java의 접근 제어자 종류와 특징에 대해 설명해주세요.</summary><br>

  <b>public</b>은 가장 개방적인 접근 제어자로, <b>어디서든 접근이 가능</b>합니다. 주로 외부에 공개해야 하는 API나 메서드에 사용합니다.<br>

  <b>protected</b>는 <b>같은 패키지 내의 클래스</b> 또는 <b>다른 패키지더라도 상속 관계에 있는 자식 클래스</b>에서만 접근할 수 있습니다. 이는 상속을 통한 확장을 염두에 둔 멤버들에 주로 사용합니다.<br>
  
  <b>default(package-private)</b>는 접근 제어자를 명시하지 않으면 적용되는 기본값으로, <b>같은 패키지 내에서만 접근</b>이 가능합니다. 따라서 이는 패키지 단위로 모듈화할 때 유용합니다.<br>
  
  <b>private</b>은 가장 제한적인 접근 제어자로, <b>같은 클래스 내에서만 접근</b>할 수 있습니다. 따라서 외부에 노출되어서는 안 되는 내부 구현 세부사항을 숨기는 데 사용합니다.
</details>

<details>
  <summary>Java의 원시 타입들은 무엇이 있으며 각각 몇 바이트를 차지하나요?</summary><br>

  먼저 정수형 타입으로는 1byte 크기의 <b>byte</b>, 2byte 크기의 <b>short</b>, 4byte 크기의 <b>int</b>, 8byte 크기의 <b>long</b>이 있습니다.<br>

  실수형 타입으로는 4byte 크기의 <b>float</b>, 8byte 크기의 <b>double</b>이 있으며, 문자형 타입으로는 2byte 크기의 <b>char</b>가 있고, 논리형 타입으로는 1byte 크기의 <b>boolean</b>이 있습니다.

  > <b>char가 2byte인 이유</b><br>
  > 이는 유니코드를 지원하기 위해서입니다. 1byte로는 영어 알파벳과 기본 기호만 표현할 수 있기 때문에 한국어, 중국어, 일본어 등 다국어 지원이 불가능합니다. 따라서 char는 유니코드에 포함되어 있는 모든 문자를 표현할 수 있도록 2byte로 설계되었습니다.
</details>

<details>
  <summary>Java는 Call By Value와 Call By Reference 방식 중 어떤 것을 사용하나요?</summary><br>

  <b>자바는 항상 Call By Value 방식만 사용</b>합니다. 하지만 여기서 주의할 점이 있습니다.<br>

  원시 타입(int, double, boolean 등)의 경우 값 자체가 복사되어 전달되므로 전형적인 Call By Value입니다. 따라서 메서드 내에서 값을 변경해도 원본에 영향을 주지 않습니다.<br>
  
  다만 참조 타입(객체, 배열 등)의 경우에는 <b>참조값(주소값)이 복사되어 전달</b>됩니다. 즉, 참조값 자체는 복사본이지만, 그 참조값이 가리키는 객체는 동일하기 때문에 객체의 내부 상태를 변경하면 원본 객체에 영향을 줍니다.<br>
  
  정리하면, 자바는 순수한 Call By Value 언어이지만, 참조 타입의 경우 참조값이 복사되어 전달되면서 마치 Call By Reference처럼 보이는 효과가 나타날 뿐입니다.
</details>

<details>
  <summary>Java의 static에 대해 설명해주세요.</summary><br>

  `static`은 <b>클래스 레벨에 속한다는 의미</b>입니다. 객체를 생성하지 않고도 클래스 이름으로 직접 접근할 수 있으며, 모든 인스턴스가 공유하는 특성을 가집니다.<br>

  `static` 멤버들은 JVM 메모리의 <b>메서드 영역(Method Area)</b>에 저장됩니다. 따라서 클래스가 처음 로딩될 때 한 번만 메모리에 할당되고, 프로그램이 종료될 때까지 유지됩니다.
</details>

<details>
  <summary>String, StringBuffer, StringBuilder의 차이에 대해 설명해주세요.</summary><br>

  `String`은 <b>불변(immutable) 객체</b>입니다. 한 번 생성하면 내용을 변경할 수 없고, 문자열 연산을 할 때마다 새로운 `String` 객체가 생성됩니다. 즉, 기존 객체를 수정하는 것이 아니라 새로운 `String` 객체를 만들어 참조만 바꿉니다.<br>

  `StringBuffer`와 `StringBuilder`는 둘 다 <b>가변(mutable) 객체</b>입니다. 내부 버퍼를 가지고 있어서 문자열을 수정할 때 새로운 객체를 생성하지 않고 기존 버퍼의 내용을 변경합니다. 이 둘의 가장 핵심적인 차이점은 <b>동기화 지원 여부</b>입니다.<br>
  - `StringBuffer`는 <b>thread-safe</b>합니다. 모든 메서드가 `synchronized`로 동기화 처리되어 있어서 멀티스레드 환경에서 안전하게 사용할 수 있습니다. 하지만 동기화 오버헤드로 인해 성능이 상대적으로 낮습니다.<br>
  - `StringBuilder`는 <b>thread-unsafe</b>합니다. 동기화 처리가 되어 있지 않아서 멀티스레드 환경에서 안정성이 낮지만, 그만큼 성능은 높습니다.
  
  따라서 싱글스레드 환경에서 문자열 조작이 많다면 `StringBuilder`를, 멀티스레드 환경에서 문자열 조작이 필요하다면 `StringBuffer`를, 단순한 문자열 저장이나 적은 연산이라면 `String`을 사용하면 됩니다.

  > <b>Thread-safe</b><br>
  > Thread-safe란 멀티 스레드 환경에서 여러 스레드가 동시에 같은 코드나 객체에 접근해도 안전하게 동작하는 것을 의미합니다. 즉, 동기화 메커니즘을 통해 한 번에 하나의 스레드만 임계 영역에 접근할 수 있도록 보장함으로써 데이터 손상을 방지하는 것입니다.

  > <b>왜 동기화(synchronized)가 걸려있으면 속도가 느린걸까?</b><br>
  > 동기화 처리가 되어있는 영역에 진입하기 위해서는 스레드가 락을 획득하고 해제하는 과정이 필요하며, 이러한 부가적인 작업들로 인해 속도가 느려집니다. 또한 특정 스레드가 락을 잡고 있으면, 다른 스레드들은 그 락이 해제될 때까지 대기해야 합니다. 특히 락을 오래 잡고 있는 작업이 있으면, 다른 스레드들이 모두 대기 상태에 빠져서 전체적인 처리량이 크게 떨어집니다. 또한 스레드가 블로킹되고 다시 스케줄링되는 과정에서 CPU의 컨텍스트 스위칭이 발생하는데, 짧은 시간 동안 락을 자주 획득하고 해제하는 상황에서는 컨텍스트 스위칭에 따른 오버헤드로 인해 성능이 떨어질 수 있습니다.

  > <b>싱글 스레드로 접근한다는 가정하에선 StringBuilder와 StringBuffer의 성능이 똑같을까?</b><br>
  > `StringBuffer`의 경우 모든 메서드가 `synchronized`로 동기화되어 있기 때문에 싱글 스레드 환경에서도 메서드 호출 시마다 매번 락을 획득하고 해제하는 과정을 수행합니다. 즉, `StringBuffer`는 여전히 메서드 호출에 부가적인 비용이 들며, 따라서 완전히 동기화가 없는 `StringBuilder`에 비해 느립니다.
</details>

<details>
  <summary>불변 객체란 무엇인지 설명해주세요.</summary><br>

  불변 객체는 <b>한 번 생성된 후에 그 상태를 변경할 수 없는 객체</b>를 말합니다. 객체가 생성된 시점 이후로는 내부 데이터를 수정할 수 없어서, 항상 동일한 상태를 유지합니다.<br>

  이러한 불변 객체의 장점으로는 <b>스레드 안전성</b>이 있습니다. 상태가 변하지 않으니까 여러 스레드에서 동시에 접근해도 문제가 없습니다. 또한 객체의 `hashCode`가 변하지 않아서 `HashMap` 같은 곳에서 Key로 사용하기에 안전합니다.<br>
  
  단, 불변 객체를 수정하고자 할 경우에는 항상 새로운 객체를 생성해야 하기 때문에 이에따른 <b>메모리 누수</b>와 <b>성능 저하</b>가 발생할 수 있습니다.
</details>

<details>
  <summary>Java의 String이 불변객체인 이유에 대해 설명해주세요.</summary><br>

  첫 번째는 <b>메모리 효율성</b> 때문입니다. 자바는 <b>String Constrant Pool</b>이라는 특별한 메모리 영역을 사용해서 동일한 문자열 리터럴을 하나의 객체로 공유합니다. 예를 들어 특정 문자열이 여러 곳에서 사용되면 자바는 객체를 하나만 생성해서 참조를 공유하는 방식으로 동작하는데, 만약 `String`이 가변 객체라면 한 곳에서 값을 변경했을 때 다른 모든 곳이 영향을 받게 됩니다.<br>

  두 번째는 <b>Thread-Safety</b> 입니다. 불변 객체는 본질적으로 멀티 스레드 환경에서 안전합니다. 여러 스레드가 동시에 같은 `String`에 접근해도 내용 자체가 변경될 수 없기 때문에 별도의 동기화 처리 없이도 안전하게 사용할 수 있습니다.<br>
  
  세 번째는 <b>성능상의 이점</b>입니다. `String`은 `hashCode`를 한 번 계산하면 내부적으로 캐싱해둡니다. 내용이 바뀔 일이 없으니까 매번 다시 계산할 필요가 없어서 `HashMap` 같은 자료구조에서 Key로 사용할 때 성능이 향상됩니다.<br>
  
  이런 장점들 때문에 문자열 연산 시 새 객체를 생성해야 하는 단점이 있음에도 불구하고 자바는 `String`을 불변으로 설계하였습니다.
</details>

<details>
  <summary>Java의 컬렉션 프레임워크에 대해 설명해주세요.</summary><br>

  Java에서 컬렉션 프레임워크란 <b>다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스들의 집합</b>을 의미합니다.<br>

  즉, 데이터를 저장하는 자료구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현해놓은 것입니다.<br>

  이러한 컬렉션 프레임워크는 Java의 인터페이스를 사용하여 구현됩니다.<br>

  컬렉션 프레임워크에서는 `List`, `Set`, `Map`과 같이 데이터를 저장하는 주요 자료구조에 따라 인터페이스를 정의하고 있습니다.<br>

  이 중에서 `List`와 `Set` 인터페이스는 모두 `Collection` 인터페이스를 상속받지만, 구조상의 차이로 인해 `Map` 인터페이스는 별도로 정의됩니다.
</details>

<details>
  <summary>Java의 List, Set, Map의 차이에 대해 설명해주세요.</summary><br>

  <b>List</b>는 <b>순서가 있고 중복을 허용하는 컬렉션</b>입니다. 인덱스로 요소에 접근할 수 있고, 같은 값을 여러 번 저장할 수 있습니다.<br>

  <b>Set</b>은 <b>순서가 없고 중복을 허용하지 않는 컬렉션</b>입니다. 수학의 집합 개념과 같아서 동일한 요소는 하나만 존재할 수 있습니다.<br>
  
  <b>Map</b>은 <b>순서 없이 키와 값의 쌍으로 데이터를 저장하는 컬렉션</b>입니다. 키는 중복될 수 없지만 값은 중복 가능하며, 키를 통해 값에 접근합니다.<br>
</details>

<details>
  <summary>ArrayList는 내부적으로 어떻게 구현되어있나요?</summary><br>

  `ArrayList`는 내부적으로 `Object` 배열을 사용하여 데이터를 저장합니다. 따라서 배열의 인덱스 기반 접근 방식을 그대로 활용하기 때문에 O(1) 시간 복잡도로 get/set 연산이 가능합니다.<br>
  
  삽입, 삭제 연산도 배열과 동일하게 모든 요소들을 한 칸씩 이동시키는 작업이 필요하기 때문에 최악의 경우 O(n)의 시간복잡도가 걸립니다.<br>

  `ArrayList`는 요소를 추가할 때 배열이 가득 차면 현재 크기의 1.5배로 새로운 배열을 생성한 후 기존 데이터를 새로운 배열로 복사하는 방식으로 동작합니다.
</details>

<details>
  <summary>클래스, 객체, 인스턴스의 차이에 대해 설명해주세요.</summary><br>

  <b>클래스(Class)</b>는 객체를 만들기 위한 설계도나 틀입니다. 객체가 가져야 할 속성(필드)과 행동(메서드)을 정의해놓은 것입니다. 즉, 아직 실제로 존재하는 것이 아니라 개념적인 설계도입니다.<br>

  <b>객체(Object)</b>는 클래스를 바탕으로 실제로 생성된 실체입니다. 즉, 클래스라는 설계도를 이용해서 메모리에 실제로 만들어진 것입니다.<br>
  
  <b>인스턴스(Instance)</b>는 객체를 부르는 다른 이름입니다. 인스턴스는 영어로 “사례” 혹은 “예시”를 의미합니다. 즉, 객체를 인스턴스라고 부르는 것은 그 객체가 특정 클래스로 만든 객체의 구체적인 사례(실제 예)임을 강조할 때 사용합니다. 또한 객체가 실제로 메모리에 할당된 상태를 강조하는 의미로 인스턴스라고 부르기도 합니다.
</details>

<details>
  <summary>인터페이스와 추상 클래스의 차이에 대해 설명해주세요.</summary><br>

  <b>추상 클래스</b>는 <b>상속 관계에서 공통 기능을 제공하면서도 일부 기능은 각자 구현하도록 강제</b>함으로써, 공통된 특성을 추상화하고 상속에 대한 계층 구조를 명확히 표현하는데에 그 목적이 있습니다.<br>
  
  <b>인터페이스</b>는 <b>특정 역할이나 기능을 수행하기 위해 반드시 구현해야 할 메서드들을 명세하는 것</b>으로, 서로 다른 클래스들이 같은 인터페이스를 구현함으로써 결과적으로는 해당 인터페이스의 구현 객체들이 동일한 방식으로 사용될 수 있도록 보장하는 것에 그 목적이 있습니다.<br>

  추상 클래스와 인터페이스의 문법적인 차이는 다음과 같습니다.
  - 추상 클래스는 단일 상속만 가능하며, 인터페이스는 다중 구현이 가능합니다.
  - 추상 클래스는 모든 접근 제어자를 사용할 수 있지만, 인터페이스는 public 접근 제어자만 사용할 수 있습니다.
  - 추상 클래스는 변수와 상수를 선언할 수 있지만, 인터페이스는 상수만 선언할 수 있습니다.
</details>

<details>
  <summary>Java에서 다중 상속을 지원하지 않는 이유에 대해 설명해주세요.</summary><br>

  이는 <b>Diamond Problem</b> 때문입니다. 하나의 조상 클래스가 있고 이 조상 클래스를 상속받아 메서드를 각각 다르게 오버라이딩 하는 두 개의 부모 클래스가 있고, 이 두 부모 클래스를 상속받는 자식 클래스가 있다고 할 때, 자식 클래스에서는 어떤 부모 클래스의 메서드를 사용할지 결정할 수 없는 모호성 문제가 발생합니다.<br>

  C++에서는 다중 상속을 허용하되, 이러한 충돌 상황에 대해서는 개발자가 명시적으로 해결하도록 지원하지만, Java는 이러한 기능 자체를 원천 차단하여 <b>애초에 문제가 발생할 수 있는 상황 자체를 만들지 않는 방식으로 설계</b>되었습니다.
  
  대신 Java는 <b>인터페이스를 통한 다중 구현을 지원</b>합니다. 인터페이스는 구현체가 없는 추상 메서드만을 가지기 때문에 Diamond Problem이 발생하지 않으며, Java8 부터 인터페이스에 default 메서드가 추가되긴 했지만, 충돌 시 컴파일 타임에 오류를 발생시키며 명시적으로 구현하도록 강제함으로써 모호성을 해결하였습니다.
</details>

<details>
  <summary>CheckedException과 UncheckedException의 차이에 대해 설명해주세요.</summary><br>

  <b>CheckedException</b>은 <b>컴파일 시점에 반드시 예외 처리를 해야 하는 예외</b>입니다. `try-catch` 블록으로 처리하거나 `throws` 키워드로 상위 메서드에 예외를 위임해야 합니다. 만약 처리하지 않으면 컴파일 에러가 발생합니다. 대표적으로 `IOException`, `SQLException`, `ClassNotFoundException` 등이 있습니다.

  <b>UncheckedException</b>은 <b>컴파일 시점에 예외 처리를 강제하지 않는 예외</b>입니다. 개발자가 선택적으로 처리할 수 있고, 처리하지 않아도 컴파일은 됩니다. 하지만 런타임에 발생하면 프로그램이 비정상 종료될 수 있습니다. `RuntimeException`을 상속받는 예외들로, `NullPointerException`, `ArrayIndexOutOfBoundsException`, `IllegalArgumentException` 등이 있습니다.
  
  CheckedException은 접근하려는 파일이 존재하지 않거나, 네트워크 연결이 끊어지거나, 데이터베이스 접근에 실패하는 등 주로 <b>외부 요인</b>에 의해 발생하는 반면, UncheckedException은 null 참조, 배열 범위 초과, 잘못된 매개변수 전달 등 주로 <b>프로그래밍 오류</b>에 의해 발생합니다.
</details>

<details>
  <summary>try-with-resource에 대해 설명해주세요.</summary><br>

  Java 7에서 도입된 <b>자동 자원 관리 구문</b>으로, `AutoCloseable` 인터페이스를 구현한 자원들을 `try` 블록이 끝날 때 자동으로 `close()` 해주는 기능입니다.<br>

  기존에는 `finally` 블록에서 수동으로 `close()`를 호출해야 했지만, `try()` 문 안에 사용할 리소스 객체를 명시적으로 선언하여 사용하면, 로직이 완료될 때 JVM에서 자동으로 자원을 해제하도록 하여, 혹시 모를 메모리 누수와 코드 복잡성을 해결할 수 있습니다.
</details>

<details>
  <summary>오버로딩과 오버라이딩의 차이에 대해 설명해주세요.</summary><br>

  <b>오버로딩(Overloading)</b>은 <b>같은 클래스 내에서 같은 이름의 메서드를 여러 개 정의하는 것</b>입니다. 메서드 이름은 동일하지만 매개변수의 개수, 타입, 순서가 달라야 합니다.<br>

  <b>오버라이딩(Overriding)</b>은 <b>부모 클래스에서 정의된 메서드를 자식 클래스에서 재정의하는 것</b>입니다. 메서드의 이름, 매개변수, 리턴 타입과 같은 메서드 시그니처가 모두 동일해야 합니다.<br>
  
  즉, 오버로딩은 <b>편의성</b>을 위한 기능이고, 오버라이딩은 <b>다형성</b>을 위한 기능이라고 할 수 있습니다.
</details>

<details>
  <summary>HashMap, HashTable, ConcurrentHashMap의 차이에 대해 설명해주세요.</summary><br>

  `HashMap`은 Thread-unsafe한 자료구조입니다. 동기화 처리를 하지 않기 때문에 단일 스레드 환경에 사용하기에 적합하며, 가장 빠른 성능을 보여줍니다.<br>

  `HashTable`은 `HashMap`과 달리 모든 메서드가 `synchronized`로 동기화되어 있어서 Thread-safe 합니다. 단, 메서드 레벨에서 락(Lock)을 걸기 때문에 한 번에 하나의 스레드만 해당 메서드에 접근할 수 있어 성능이 상당히 떨어집니다. 따라서 최근에는 거의 사용하지 않는 레거시 클래스라고 볼 수 있습니다.<br>
  
  `ConcurrentHashMap`은 `HashTable`처럼 테이블 전체에 락을 거는게 아니라 버킷(Bucket) 레벨에 락을 걸어, 여러 스레드가 서로 다른 버킷에 대해서는 동시에 접근할 수 있도록 처리하여, 멀티 스레드 환경에서 최적화된 성능을 보여줍니다.
</details>

<details>
  <summary>new String()과 “”의 차이에 대해 설명해주세요.</summary><br>

  가장 큰 차이는 메모리 할당 방식입니다.<br>

  문자열 리터럴(`""`)은 JVM의 <b>String Pool</b>에 저장됩니다. 리터럴 방식으로 문자열을 선언할 경우 JVM은 String Pool에 해당 문자열이 이미 존재하는지 확인하고, 있다면 그 주소를 재사용하는 방식으로 동작합니다. 따라서 동일한 문자열의 경우 같은 메모리 주소를 참조하게 되며, 이를 통해 <b>메모리를 절약</b>할 수 있습니다.<br>
  
  반면 `new` 키워드를 사용하여 문자열 객체를 생성할 경우 힙 메모리에 새로운 `String` 객체를 생성합니다. 이 경우 설령 같은 내용이더라도 매번 새로운 객체가 만들어지게 되므로 <b>불필요한 객체 생성으로 인한 메모리 누수와 GC 부담이 증가</b>할 수 있습니다.
</details>

<details>
  <summary>Java의 리플렉션과 동적 프록시에 대해 설명해주세요.</summary><br>

  <b>리플렉션(Reflection)</b>은 <b>객체를 통해 클래스의 정보를 분석하여 런타임에 클래스의 동작을 검사하거나 조작하는 프로그래밍 기법</b>입니다. 클래스 파일의 위치나 이름만 있다면 해당 클래스의 정보를 얻어내고, 객체를 생성하는 것 또한 가능하게 해주어 유연한 프로그래밍이 가능합니다.

  리플렉션은 애플리케이션 개발보다는 <b>프레임워크</b>, <b>라이브러리</b> 개발에서 주로 사용됩니다. 프레임워크나 라이브러리는 사용자가 어떤 클래스를 만들지, 그 클래스에 어떤 필드나 메서드가 있을지 전혀 모르는 상태에서, 이러한 사용자 클래스들을 본인들이 만든 기능과 동적으로 연결시키기 위해 리플렉션을 사용합니다. 대표적인 예로 Spring, Hibernate, Lombok 등이 있습니다.
  
  <b>동적 프록시</b>는 <b>런타임에 프록시 객체를 동적으로 생성하는 기술</b>입니다. 기존의 정적 프록시와 달리, 컴파일 타임에 프록시 클래스를 미리 만들어두지 않고 실행 중에 필요할 때 생성하는 방식으로, <b>리플랙션을 활용한 대표적인 응용 사례</b>입니다.
  
  Java에서 동적 프록시를 구현하는 방법으로는 크게 두 가지가 있습니다.
  
  <b>JDK 동적 프록시</b>는 <b>인터페이스</b>를 기반으로 동작하며, 특정 인터페이스를 구현한 프록시 객체를 런타임에 생성하는 방식입니다.
  
  <b>CGLIB 동적 프록시</b>는 <b>클래스 기반</b>으로 동작해서 인터페이스 없이도 프록시를 만들 수 있습니다. 이는 바이트코드 조작을 통해 <b>타겟 클래스를 상속받은 서브클래스를 생성하는 방식</b>입니다. 해당 라이브러리의 경우 오히려 JDK 동적 프록시에 비해 성능이 좋으며, 그 효용성을 인정받아 스프링 프레임워크에서 기본으로 내장되어 사용되고 있습니다.
  
  이에 대한 가장 대표적인 사용 사례가 <b>Spring AOP</b>입니다. Spring에서 `@Transactional` 같은 어노테이션을 붙이면, 해당 메서드 호출 전후에 부가 기능이 실행되는데, 이게 바로 동적 프록시를 통해 구현됩니다.
  
  동적 프록시 기법을 사용하면 코드 중복을 줄이고, 횡단 관심사를 분리할 수 있으며, 런타임에 유연하게 프록시를 생성할 수 있습니다. 하지만 리플렉션 기법을 사용하기 때문에 성능 오버헤드가 있고, 디버깅이 어려울 수 있다는 단점도 존재합니다.
</details>

<details>
  <summary>JDK, JRE, JVM의 차이에 대해 설명해주세요.</summary><br>

  <b>JVM(Java Virtual Machine)</b>은 자바 바이트코드를 실행하는 가상 머신입니다. 이때 바이트코드를 해당 OS의 네이티브 코드로 변환해서 실행하며, 이를 통해 플랫폼 독립적인 실행 환경을 제공합니다. 또한 가비지 컬렉션을 통한 메모리 관리, 스레드 관리 등의 역할을 담당합니다.
  
  <b>JRE(Java Runtime Environment)</b>는 자바 프로그램을 실행하기 위한 환경입니다. JVM을 포함하고 있으며, 추가로 표준 라이브러리(java.lang, java.util 등)와 기타 실행에 필요한 파일들로 구성됩니다.
  
  <b>JDK(Java Development Kit)</b>는 자바로 개발을 하기 위한 전체적인 도구들의 모음입니다. JRE를 포함한 각종 개발 도구들(javac 컴파일러, javadoc, jar, debugger 등)을 포함합니다. 자바 애플리케이션을 개발, 컴파일, 실행, 디버깅할 수 있는 완전한 환경을 제공합니다.
</details>

<details>
  <summary>JVM의 메모리 구조에 대해 설명해주세요.</summary><br>

  JVM 메모리 영역은 크게 <b>메서드 영역, 힙 영역, 스택 영역, PC 레지스터, 네이티브 메서드 스택 영역</b>으로 나눌 수 있습니다. 여기서 메서드 영역과 힙 영역은 모든 스레드가 공유하는 영역이고, 나머지 스택 영역과 PC 레지스터, 네이티브 메서드 스택 영역은 스레드별로 독립적으로 생성되는 영역입니다.

  <b>메서드 영역</b>은 클래스 메타데이터, 상수 풀(Constant Pool), static 변수 등이 저장되는 영역입니다. 메서드 영역은 Java 7 버전까지는 JVM 메모리 영역에 PermGen으로 구현이 되었고, Java 8 버전 이후부터는 OS에 의해 관리되는 네이티브 메모리 영역에 Metaspace로 구현 되었습니다.
  
  <b>힙 영역</b>은 객체나 배열 같은 참조 타입이 저장되는 공간으로, GC의 대상이 되는 영역입니다. 힙은 효율적인 GC를 위해 Young Generation과 Old Generation으로 나뉘어 있고, Young Gerneration은 또다시 Eden 영역과 두 개의 Survivor 영역으로 나뉩니다. Eden 영역은 새로 생성된 객체들이 가장 먼저 할당되는 영역이며, GC에서 살아남은 객체들은 Survivor 영역으로 이동합니다. 그리고 Young Generation에서 age가 임계치까지 도달한 객체들은 Old Generation으로 이동하게 됩니다.
  
  <b>스택 영역</b>은 메서드 호출 시 생성되는 지역 변수, 매개 변수, 리턴 주소 등이 저장되는 영역입니다. 스택 영역은 데이터를 스택 프레임 단위로 관리하며, 메서드가 종료되면 해당 스택 프레임은 제거됩니다.
  
  <b>PC 레지스터</b>는 각 스레드가 현재 실행중인 JVM 명령어의 주소를 저장하는 영역입니다.
  
  <b>네이티브 메서드 스택 영역</b>은 JNI를 통해 호출되는 C/C++ 등의 네이티브 코드를 실행하기 위한 스택 영역입니다.
</details>

<details>
  <summary>Garbage Collector의 동작 원리에 대해 설명해주세요.</summary><br>

  GC의 기본 원리는 더 이상 사용되지 않는 객체들을 자동으로 찾아서 힙 메모리에서 해제하는 것입니다. 이때 가장 중요한 개념이 <b>도달 가능성(Reachability)</b>인데, GC Root라고 불리는 시작점들로부터 참조 체인을 따라가면서 도달할 수 있는 객체와 도달할 수 없는 객체를 분리한 후 Unreachable한 객체는 가비지(Garbage)로 판단하여 제거하는 방식입니다.
  
  이러한 수집 알고리즘을 Mark & Sweep이라고 하며 GC 알고리즘의 종류에 따라 메모리 단편화를 해결하기 위한 Compact 단계가 추가로 진행되기도 합니다.
</details>

<details>
  <summary>GC 알고리즘에 대해 설명해주세요.</summary><br>

  <b>Serial GC는</b> 가장 단순한 GC로, GC를 싱글 스레드로 처리하기 때문에 STW(Stop the World) 시간이 가장 긴 알고리즘입니다.

  <b>Parallel GC</b>는 Java 8의 디폴트 GC로, Serial GC를 멀티 스레드로 개선한 버전입니다. 여러 스레드가 병렬로 GC 작업을 수행해서 처리 시간을 단축시키지만, 여전히 STW 시간이 존재합니다.
  
  <b>CMS GC</b>는 Concurrent Mark Sweep의 줄임말로, 애플리케이션과 동시에 GC 작업을 수행해서 응답 시간을 개선하였습니다. 다만, Compaction 단계의 부재로 인한 메모리 단편화 문제와 복잡한 GC 과정으로 인한 CPU 사용량 문제로 인해 Java 14부터 제거되었습니다.
  
  <b>G1GC</b>는 Java 9부터 설정된 디폴트 GC으로, 큰 힙 메모리에서 낮은 지연 시간을 목표로 설계되었습니다. 힙을 여러 Region으로 나누고, 각 Region에 Eden, Survivor, Old 등의 역할을 동적으로 할당하는 방식이며, 이를 통해 탐색할 때 힙 전체를 탐색하는 것이 아니라 부분적으로(Region 단위로) 탐색함으로써 가비지가 많은 Region을 우선적으로 GC하여 효율성을 높였습니다.
  
  <b>ZGC</b>는 초저지연을 목표로 하는 최신 GC입니다. G1GC의 Region처럼, ZGC는 ZPage라는 영역을 사용하며, G1GC의 Region은 크기가 고정인데 비해 ZPage는 Small(2MB), Medium(32MB), Large(2MB 배수)로 동적으로 운영한다는 차이가 있습니다. ZGC는 Colored Pointer를 사용하여 객체의 상태를 관리하고 Load Barrier를 사용해서 안전한 메모리 접근을 보장함으로써 대부분의 작업을 동시에 수행하고, 힙 크기에 관계없이 10ms 이하의 STW 시간을 보장합니다.
</details>

<details>
  <summary>제네릭이란 무엇이고, 왜 사용하는지 설명해주세요.</summary><br>

  제네릭은 <b>클래스나 메서드에서 사용할 타입을 컴파일 타임에 지정할 수 있게 해주는 기능</b>입니다. 제네릭으로 작성된 클래스나 메서드의 경우에는 타입을 파라미터로 받아서 코드 작성 시점에는 구체적인 타입을 결정하지 않고, 그것을 실제로 사용할 때 타입을 지정할 수 있습니다.

  제네릭을 사용하는 가장 큰 이유는 <b>타입 안전성</b>을 확보하기 위해서입니다. 제네릭이 없던 시절(Java5 이전)에는 컬렉션에서 객체를 꺼낼 때마다 형변환을 해야했고, 이때 혹시라도 엉뚱한 타입의 객체가 컬렉션에 포함되어 있을 경우 런타임에 형변환 오류가 발생하는 문제가 있었습니다. 제네릭을 사용하면 컴파일 타임에 오류를 검출할 수 있어 보다 안전하고 명확한 프로그래밍이 가능합니다.
</details>

<details>
  <summary>어노테이션에 대해 설명해주세요.</summary><br>

  어노테이션은 <b>코드에 메타데이터를 추가하는 방법</b>으로, 클래스, 메서드, 필드 등에 추가 정보를 제공하며, 코드 자체의 동작에는 직접적인 영향을 주지 않습니다.

  어노테이션은 컴파일 시 사용할 정보를 컴파일러에게 제공하거나(`@Override` 등), 빌드 툴이 코드를 자동으로 생성할 때 필요한 정보를 제공하거나(`@Entity`, `@Component` 등), 런타임에 특정 기능을 처리할 때 필요한 정보를 전달하기 위해(`@RequestMapping`, `@Transactional` 등) 사용됩니다.
</details>
<details>
  <summary>동일성과 동등성에 대해 설명해주세요.</summary><br>

  <b>동일성(Identity)</b>은 두 객체가 메모리상에서 정말로 같은 객체인지를 의미합니다. `==` 연산자로 확인하며, <b>참조값(주소값)</b>이 같은지를 비교합니다.

  <b>동등성(Equality)</b>은 두 객체가 논리적으로 같은 값을 가지는지를 의미합니다. `equals()` 메서드로 확인하며, 객체의 <b>내용</b>이 같은지를 비교합니다.
</details>

<details>
  <summary>Java의 모든 클래스는 Object 클래스를 상속 받습니다. 그리고 Object 클래스에는 equals()와 hashCode() 메서드가 선언되어 있습니다. 이 메서드들은 각각 어떤 역할을 할까요?</summary><br>

  `equals()` 메서드는 두 객체의 논리적 동등성을 판단하는 역할을 합니다. `Object` 클래스의 기본 구현에서는 참조값을 비교하는 연산과 동일하게 동작하지만, 대부분의 클래스에서는 객체의 내용을 비교하도록 오버라이드해서 사용합니다.

  `hashCode()` 메서드는 해당 객체가 해시 테이블에 저장될 때 사용할 해시값을 반환하는 메서드입니다.

  중요한 점은, 이 둘이 <b>일관성</b>을 유지해야 한다는 점입니다. 즉, 두 객체에 대한 `equals()` 메서드의 결과가 `True`라면 두 객체의 해시값도 반드시 동일해야 합니다.
</details>

<details>
  <summary>hashCode()를 잘못 오버라이딩하면 HashMap과 같은 해시 컬렉션의 성능이 떨어질 수가 있습니다. 어떤 케이스일 때 그럴 수 있을까요?</summary><br>

  모든 객체가 같은 해시값을 반환하거나 해시값의 분포가 매우 불균등한 경우 모든 객체가 특정 버킷에 몰려서 연결 리스트나 트리 형태로 저장되며, 본래 O(1)의 시간 복잡도를 가지는 검색 속도가 최악의 경우 O(n)으로 떨어져 성능이 크게 악화될 수 있습니다.

  또한 `hashCode()`는 해시 컬렉션에 객체를 저장하거나 검색할 때마다 호출되므로, 해시값 계산 비용이 너무 높은 경우에도 성능이 악화될 수 있습니다.
</details>

<details>
  <summary>System.out.println() 메서드는 현업에서 절대 쓰지 말라고 하는 메서드인데요. 그 이유가 무엇일까요?</summary><br>

  가장 큰 문제는 성능입니다. `System.out.println()`은 내부적으로 `synchronized` 키워드를 포함하고 있어 동기적으로 동작하기 때문에 콘솔에 출력할 때마다 스레드가 블로킹되며, 이로 인한 성능저하가 발생하게 됩니다.

  또한 로그 레벨 제어가 불가능하기 때문에 필요에 따라 로그 출력을 조절할 수 없다는 문제도 존재합니다. 따라서 현업에서는 Logback 같은 로깅 프레임워크를 사용해서 로그 레벨을 제어하고 비동기 로깅으로 성능을 최적화하는 것이 일반적입니다.
</details>

<details>
  <summary>Serializable에 대해 설명해주세요.</summary><br>

  Serializable(직렬화)이란 자바에서 사용되는 데이터를 다른 자바 시스템에서 사용할 수 있도록 연속적인 바이트 스트림 형태의 데이터로 변환하는 기술을 말합니다.

  직렬화를 사용하면 JVM 메모리에만 상주하는 데이터를 영속화할 수 있으며, 시스템이 종료되더라도 이를 보존할 수 있습니다. 또한 영속화된 데이터이기 때문에 네트워크로 전송이 가능합니다.

  `Serializable은` Java의 마커 인터페이스로, 해당 객체를 바이트 스트림으로 변환할 수 있다는 것을 JVM에게 알려주는 역할을 합니다. 실제로 구현해야 할 메서드는 없고, 단순히 직렬화가 가능함을 표시하는 것입니다.

  `serialVersionUID`는 Java의 직렬화 과정에서 클래스의 버전을 식별하는 고유 식별자로, 이 값을 통해 직렬화할 때와 역직렬화할 때의 클래스 버전이 같은지 확인할 수 있으며, 직렬화된 데이터의 안정성과 버전 호환성을 관리할 수 있습니다.
</details>

<details>
  <summary>Virtual Thread에 대해 설명해주세요.</summary><br>

  Virtual Thread는 기존에 Kernel-Level-Thread와 User-Level-Thread를 1대1 매핑하여 사용하던 JVM의 스레드 모델을 개선하여, 여러 개의 Virtual Thread를 하나의 Native Thread에 할당해서 사용하는 모델로, Java 21에서 정식 도입된 경량 스레드입니다.

  Virtual Thread의 가장 큰 특징은 메모리 사용량이 극적으로 적다는 점입니다. 기존 Platform Thread가 1~2MB 정도 크기의 스택을 가지는 반면, Virtual Thread는 몇 KB 수준으로 시작해서 필요에 따라 동적으로 확장됩니다.

  Virtual Thread는 내부적으로 적은 수의 Carrier Thread(= Platform Thread) 위에서 실행됩니다. I/O 작업이나 블로킹이 발생하면 Virtual Thread는 Carrier Thread에서 분리되고, 다른 Virtual Thread가 그 자리를 사용하는데 이를 'unmounting'이라고 부릅니다.

  Virtual Thread는 특히 I/O 집약적인 작업에서 성능이 뛰어납니다. 기존에는 스레드가 I/O를 기다리는 동안 Native Thread가 블로킹되었는데, Virtual Thread는 블로킹 시 자원을 반납하고 이를 통해 다른 작업을 처리할 수 있어서 처리량을 크게 향상시킬 수 있습니다.

  단, CPU 집약적 작업에서는 기존 스레드와 성능 차이가 크지 않고, `synchronized` 블록에서는 여전히 Native Thread가 블로킹될 수 있어서 이러한 경우에는 ReentrantLock 사용을 권장하고 있습니다.

  `synchronized`는 OS가 Native Thread를 기준으로 락을 관리하기 때문에 Virtual Thread가 다른 Native Thread로 이동할 수 없지만, ReentrantLock은 JVM이 Virtual Thread를 기준으로 락을 관리하기 때문에 자유롭게 이동할 수 있습니다.

  > <b>ReentrantLock</b>  
  > ReentrantLock은 Java에서 동시성 제어를 위한 동기화 메커니즘 중 하나로, 수동으로 잠금 영역의 시작점과 끝점을 설정할 수 있으며 `synchronized`보다 유연한 동기화를 제공합니다.
</details>

<details>
  <summary>Java 버전 별 주요 변경사항에 대해 설명해주세요.</summary><br>

  <b>Java 8</b>에서는 람다 표현식, Stream API, Optional, 새로운 Date/Time API가 도입되었습니다.

  <b>Java 11</b>에서는 HTTP Client API 표준화, String 클래스 개선(`strip()`, `isBlank()`, `lines()` 등), `var` 키워드를 사용한 지역 변수 타입 추적 등의 기능이 도입되었습니다.

  <b>Java 17</b>에서는 `record` 클래스가 정식 기능이 되어 불변 데이터 클래스를 간편하게 만들 수 있고, `sealed` 클래스를 통한 상속 제한이 가능해졌습니다. 또한 `switch` 표현식이 개선되었습니다.

  <b>Java 21</b>에서는 Virtual Thread가 도입되어 기존 스레드 모델의 한계를 극복함으로써 대규모 동시성 처리가 가능해졌고, `switch` 표현식의 패턴 매칭이 가능해졌습니다.
</details>

<details>
  <summary>서블릿에 대해 설명해주세요.</summary><br>

  서블릿은 <b>웹 서버에서 동적인 웹 페이지나 웹 서비스를 제공하기 위해 Java로 작성된 클래스</b>입니다.

  서블릿은 Tomcat과 같이 서블릿을 지원하는 서블릿 컨테이너에 의해 관리되며, 서블릿 컨테이너는 서블릿 객체의 전체 생명주기를 관리합니다. 이때 서블릿 객체는 싱글톤으로 관리되며, 동시 요청을 위한 멀티 스레딩을 지원합니다.

  Spring과의 관계에서 서블릿은 Spring MVC의 `DispatcherServlet`이 상속받아 구현하고 있습니다.
</details>

<details>
  <summary>서블릿의 동작 방식에 대해 설명해주세요.</summary><br>

  웹 애플리케이션이 실행되면 서블릿 컨테이너가 `web.xml`이나 어노테이션을 읽어 서블릿을 등록합니다.

  이후 클라이언트로부터 HTTP 요청이 들어오면 서블릿 컨테이너가 `HttpServletRequest`, `HttpServletResponse` 객체를 생성하여 요청 정보를 담고 응답을 처리할 준비를 합니다.

  등록된 서블릿 중 요청과 일치하는 서블릿을 찾아 `service()` 메서드를 호출하면 HTTP 메서드에 따라 `doGet()`, `doPost()` 등의 메서드가 실행됩니다.

  서블릿이 비즈니스 로직을 처리한 후 `HttpServletResponse`를 통해 클라이언트에게 응답을 보냅니다.

  처리가 완료되면 `HttpServletRequest`와 `HttpServletResponse` 객체는 소멸되고, 사용한 스레드는 스레드 풀로 반환됩니다.
</details>

---

### 🖼️ Framework

#### Spring

<details>
  <summary>Spring 프레임워크에 대해 설명해주세요.</summary><br>

  Spring은 <b>Java 기반의 엔터프라이즈 애플리케이션 개발을 위한 오픈소스 프레임워크</b>입니다.

  핵심 특징은 <b>IoC</b>와 <b>DI</b>를 통해 객체 간의 결합도를 낮추고 유연한 설계를 가능하게 하며, <b>AOP</b>를 지원하여 로깅, 트랜잭션, 보안 등 횡단 관심사를 비즈니스 로직과 분리할 수 있습니다.

  이전에 사용되었던 EJB와 같은 기술의 문제점을 보완하여 <b>POJO 기반의 가벼운 프로그래밍</b>이 가능하며, 이를 통해 높은 개발 생산성과 유지보수성을 확보할 수 있습니다.

  > <b>POJO(Plain Old Java Object)</b>  
  > POJO란 특별한 프레임워크나 기술에 종속되지 않은 순수한 Java 객체를 의미합니다. POJO는 단순한 객체이므로 단위 테스트가 쉽고, 가독성이 좋으며, 유연성 및 재사용성이 뛰어나다는 장점이 있습니다.
</details>

<details>
  <summary>IoC와 DI에 대해 설명해주세요.</summary><br>

  <b>IoC(Inversion of Control)</b>는 제어의 주도권이 개발자가 아닌 프레임워크에게 있다는 것을 의미합니다. 전통적인 방식에서는 개발자가 직접 객체를 생성하고 의존성을 관리했다면, 스프링 프레임워크에서는 이 제어권이 스프링 컨테이너로 넘어갑니다.

  <b>DI(Dependency Injection)</b>는 IoC를 구현하는 구체적인 방법 중 하나입니다. 객체가 필요로 하는 의존성을 외부에서 주입받는 방식으로, 스프링에서는 생성자 주입, Setter 주입, 필드 주입의 세 가지 방법을 제공하고 있습니다.

  단, 필드 주입의 경우 외부에서 변경이 불가능하기 때문에 테스트 하기가 어렵고, `final` 키워드를 사용할 수 없어 불변성이 보장되지 않는다는 문제가 있습니다. 또한 Setter 주입도 동일한 이유로 불변성이 보장되지 않기 때문에 스프링에서는 생성자 주입 방식을 사용하는 것을 권장하고 있습니다.
</details>

<details>
  <summary>IoC와 DI는 어떻게 동작하나요?</summary><br>

  스프링 애플리케이션이 실행되면 `ApplicationContext`라는 스프링 컨테이너가 생성되고, 스프링 빈으로 정의된 객체를 스캔 및 등록합니다.

  이후 스프링은 의존성 그래프를 분석하여 스프링 빈 생성 순서를 결정하고 리플렉션을 통해 빈 객체를 생성합니다.

  이후 인스턴스화 및 의존성 주입이 완료된 스프링 빈은 스프링 컨테이너에 등록되며, 스프링 컨테이너가 애플리케이션이 종료될 때까지 이를 관리하게 됩니다.
</details>

<details>
  <summary>스프링 빈에 대해 설명해주세요.</summary><br>

  스프링 빈(Bean)은 스프링 컨테이너가 관리하는 객체를 의미합니다. 즉, 일반적인 Java 객체와 달리 <b>스프링 컨테이너에 의해 생성, 관리, 소멸되는 객체</b>입니다.

  스프링 빈의 라이프사이클은 기본적으로 `생성` → `의존성 주입` → `초기화 콜백` → `사용` → `소멸 전 콜백` → `소멸`의 순서로 진행됩니다. 콜백 함수는 개발자가 빈의 생성과 소멸 시점에 필요한 초기화 또는 정리 작업을 수행할 때 사용합니다.

  스프링 빈을 등록하는 방법은 어노테이션을 기반으로 `@Component`와 그 특화된 형태인 `@Controller`, `@Service`, `@Repository`를 클래스에 붙여서 자동으로 등록하는 방식과, `@Configuration` 클래스 내에서 `@Bean` 어노테이션을 메서드에 붙여 수동으로 등록하는 방식이 있습니다.

  스프링 빈에는 <b>스코프(Scope)</b>라고 하는 개념이 있습니다. 이는 스프링 컨테이너가 해당 빈의 인스턴스를 어느 범위에서 관리할지를 정의하는 개념으로, 기본적으로는 애플리케이션 전체에서 하나의 인스턴스만 생성하여 공유하는 <b>싱글톤 스코프</b>가 사용됩니다.
</details>

<details>
  <summary>AOP에 대해 설명해주세요.</summary><br>

  AOP(Aspect-Oriented Programming)란 관점 지향 프로그래밍으로, <b>애플리케이션의 횡단 관심사를 모듈화하는 프로그래밍 패러다임</b>입니다.

  횡단 관심사란 로깅, 트랜잭션 관리, 보안, 성능 측정과 같이 비즈니스 로직과는 별개로 여러 모듈에 공통적으로 적용되는 기능들을 말합니다.

  AOP 통해 횡단 관심사를 모듈화하면 핵심 관심 사항과 공통 관심 사항을 분리함으로써 코드 중복을 제거하고 유지보수성을 향상시킬 수 있습니다.

  스프링 AOP는 <b>프록시 기반</b>으로 동작하며, 인터페이스가 있으면 JDK 동적 프록시를, 없으면 CGLIB 동적 프록시를 사용합니다.
</details>

<details>
  <summary>Spring과 Spring Boot의 차이에 대해 설명해주세요.</summary><br>

  <b>Spring</b>은 Java 기반의 엔터프라이즈 애플리케이션 개발을 위한 기본 프레임워크이고, <b>Spring Boot</b>는 이러한 Spring을 더 쉽고 빠르게 사용할 수 있도록 만든 확장 프레임워크입니다.

  기존에 Spring만 사용하는 경우에는 XML이나 Java Config를 통한 수동 설정이 필요했지만, Spring Boot는 개발자가 사용할 라이브러리 의존성만 추가하면 Auto Configuration을 통해 해당 라이브러리에 대한 구성(필요한 빈 설정 및 등록)을 자동으로 처리해줍니다.

  또한 Spring은 각각의 라이브러리 버전을 개발자가 직접 관리해야 했지만, Spring Boot는 Starter 의존성을 제공하여 호환되는 라이브러리들을 묶어서 관리함으로써 의존성 관리의 효율성을 높이고 프로젝트의 전체적인 구성 시간을 단축시켰습니다.

  또 Spring은 외부 WAS에 배포해서 실행해야 했지만, Spring Boot는 내장 서버를 제공하여 독립 실행이 가능합니다.

  결론적으로 Spring Boot는 <b>Spring의 복잡한 설정을 단순화하고 개발 생산성을 향상시키기 위한 도구</b>라고 할 수 있습니다.
</details>

<details>
  <summary>Spring MVC에 대해 설명해주세요.</summary><br>

  Spring MVC는 스프링 프레임워크에서 제공하는 웹 애플리케이션 개발을 위한 모듈로, MVC(Model-View-Controller) 패턴을 기반으로 한 웹 프레임워크입니다.

  Spring MVC에서는 `DispatcherServlet`이 모든 요청을 받는 Front Controller의 역할을 합니다. 따라서 `DispatcherServlet`은 `HandlerMapping`을 통해 컨트롤러를 찾고 `HandlerAdapter`를 통해 컨트롤러를 동작시키며, 비즈니스 로직 수행 이후 컨트롤러가 반환한 뷰(View)의 이름을 통해 `ViewResolver`에게 요청하여 실제 뷰 객체를 전달받고, 해당 뷰 객체를 통해 응답 데이터를 생성하여 최종적으로 클라이언트에게 응답을 반환합니다.
</details>

<details>
  <summary>Filter와 Interceptor의 차이에 대해 설명해주세요.</summary><br>

  Filter와 Interceptor는 모두 요청을 가로채서 전/후처리를 수행하는 기능이지만, 동작하는 레벨과 관리 주체가 다릅니다.

  <b>Filter</b>는 서블릿 컨테이너 레벨에서 동작하며, Java EE 표준 기술입니다. 서블릿이 호출되기 전후에 실행되어 모든 요청에 대해 적용됩니다. 인코딩 처리, 보안 검사, 로깅 등 웹 애플리케이션 전역적인 처리에 사용됩니다.

  <b>Interceptor</b>는 Spring MVC 레벨에서 동작하며, Spring 프레임워크에서 제공하는 기능입니다. DispatcherServlet이 Controller를 호출하기 전후에 실행되어 Spring MVC 요청에만 적용됩니다. 인증/인가, 로깅, Controller 공통 로직 처리 등에 사용됩니다.
</details>

<details>
  <summary>Spring의 싱글톤 패턴에 대해 설명해주세요.</summary><br>

  Spring에서 싱글톤 패턴은 스프링 컨테이너가 특정 스프링 빈 객체의 인스턴스를 하나만 생성해서 관리하는 방식입니다. 예를 들어 `@Component`로 등록한 클래스가 있다면, 스프링 컨테이너는 그 클래스의 객체를 딱 하나만 만들어서 필요할 때마다 같은 객체를 계속 재사용하게 됩니다.

  이렇게 하는 이유는 매번 새로운 객체를 만들지 않고 하나의 객체를 계속 재사용함으로써 메모리를 절약하고 성능을 향상시키기 위해서입니다. 따라서 Spring에서는 기본적으로 모든 빈이 싱글톤 스코프로 설정되어 있습니다.

  다만 주의할 점은 싱글톤 빈은 여러 스레드에서 공유되기 때문에, 상태를 가지는 필드가 있다면 동시성 문제가 발생할 수 있어서 Thread-Safe하게 설계해야 합니다.
</details>

<details>
  <summary>@Transactional에 대해 설명해주세요.</summary><br>

  `@Transactional`은 Spring에서 트랜잭션을 선언적으로 관리할 수 있게 해주는 어노테이션입니다.

  `@Transactional`을 메소드나 클래스에 붙이면, 해당 메소드가 실행될 때 자동으로 트랜잭션이 시작되고, 메소드가 정상적으로 끝나면 자동으로 커밋됩니다. 만약 중간에 예외가 발생하면 자동으로 롤백이 됩니다.

  Spring은 <b>AOP</b>를 이용해서 이것을 구현하는데, 실제로는 <b>프록시 객체</b>를 만들어서 메소드 호출 전후에 트랜잭션 시작과 종료 코드를 자동으로 삽입합니다.
</details>

<details>
  <summary>@Transactional의 동작 원리에 대해 설명해주세요.</summary><br>

  `@Transactional`의 동작 원리는 <b>Spring AOP</b>와 <b>프록시 패턴</b>을 기반으로 합니다.

  먼저 Spring이 애플리케이션을 시작할 때, `@Transactional`이 붙은 클래스나 메소드를 스캔합니다. 그러면 해당 빈에 대해서 실제 객체가 아닌 실제 객체를 상속받는 프록시 객체를 생성해서 스프링 컨테이너에 등록합니다.
  
  이 프록시 객체는 실제 객체를 감싸고 있는 래퍼 같은 개념인데, 클라이언트가 메소드를 호출하면 프록시가 그 호출을 가로챕니다.
  
  동작 과정을 보면, 먼저 프록시가 `TransactionManager`를 통해 트랜잭션을 시작합니다. 그 다음에 실제 타겟 객체의 메소드를 호출하고, 메소드가 정상적으로 완료되면 트랜잭션을 커밋합니다. 만약 `RuntimeException`이 발생하면 롤백을 수행합니다.
  
  Spring은 기본적으로 JDK 동적 프록시나 CGLIB 동적 프록시를 사용해서 프록시를 생성합니다. 인터페이스가 있으면 인터페이스를 기반으로 프록시를 구현하는 JDK 동적 프록시를, 없으면 클래스 상속을 기반으로 프록시를 구현하는 CGLIB를 사용합니다.
</details>

<details>
  <summary>@Transactional에 readOnly 속성을 사용하는 이유에 대해서 설명해주세요.</summary><br>

  `@Transactional`의 `readOnly` 속성은 해당 트랜잭션에서 데이터 변경 작업이 없다는 것을 명시적으로 선언하는 속성입니다.
  
  보통 엔티티를 조회하면 변경 감지를 위해 원본 상태를 영속성 컨텍스트의 1차 캐시에 저장해두는데, `readOnly` 속성을 `true`로 설정하여 해당 로직이 읽기 전용임을 명시적으로 선언하면, 1차 캐시에 스냅샷을 저장하는 과정을 생략하기 때문에 메모리 사용량이 줄어들고 성능이 향상됩니다. 또한 데이터 변경 불가능한 로직임을 코드로 표시할 수 있어, 다른 개발자에게 그 의도를 명확하게 표현할 수 있다는 장점도 있습니다.
</details>

<details>
  <summary>Spring에서 제공하는 트랜잭션 격리 수준에 대해 설명해주세요.</summary><br>

  격리 수준이란 여러 트랜잭션이 동시에 실행될 때 얼마나 영향을 주고받을지를 결정하는 옵션으로, Spring에서는 5가지 옵션을 제공하고 있습니다.

  `DEFAULT`는 사용하는 데이터베이스의 기본 격리 수준을 따릅니다.

  `READ_UNCOMMITED`는 가장 낮은 격리 수준으로, 다른 트랜잭션이 아직 커밋하지 않은 데이터도 읽을 수 있는 격리 수준입니다. 이로 인해 어떤 트랜잭에서 특정 데이터를 변경했다가 이후에 커밋하지 않고 롤백했는데, 다른 트랜잭션에서 변경된 데이터를 읽어버리는 Dirty Read 현상이 발생할 수 있습니다.

  `READ_COMMITD`는 커밋된 데이터만 읽을 수 있는 격리 수준입니다. 이를 통해 Dirty Read 현상은 방지했지만, 하나의 트랜잭션 내에서 같은 키를 가진 데이터를 여러 번 조회할 때, 그 사이에 다른 트랜잭션에서 해당 값을 변경하거나 삭제하여, 그 결과가 다르게 나타나는 Non-Repeatable Read 현상이 발생할 수 있습니다.

  `REPEATABLE_READ`는 같은 트랜잭션 내에서 같은 데이터를 여러 번 읽어도 항상 같은 결과를 보장하는 격리 수준입니다. 이를 통해 Non-Repeatable Read 현상은 방지했지만, 일정 범위의 데이터를 여러 번 조회할 때 이전 쿼리에서는 없던 유령 데이터가 다음 쿼리에서 나타나는 Phantom Read 현상이 발생할 수 있습니다.

  `SERIALIZABLE`은 가장 높은 격리 수준으로, 완벽한 읽기 일관성을 제공하여 모든 문제를 해결할 수 있지만, 동시성 처리 성능이 급격히 떨어질 수 있습니다.
</details>

<details>
  <summary>Spring에서 제공하는 트랜잭션 전파 옵션에 대해 설명해주세요.</summary><br>

  전파 옵션은 메서드가 호출될 때 트랜잭션을 어떻게 처리할지를 결정하는 옵션으로, Spring에서는 7가지 트랜잭션 전파 옵션을 제공합니다.

  `REQUIRED`는 기본값으로, 기존 트랜잭션이 있으면 참여하고, 없으면 새로운 트랜잭션을 시작합니다.

  `REQUIRED_NEW`는 항상 새로운 트랜잭션을 만들며, 기존 트랜잭션이 있어도 그것을 일시 중단하고 새 트랜잭션을 시작하며, 완전히 독립적으로 동작합니다.

  `SUPPORTS`는 기존 트랜잭션이 있으면 참여하고, 없으면 트랜잭션 없이 실행합니다.

  `NOT_SUPPORTS`는 트랜잭션을 사용하지 않고 실행하도록 하며, 기존 트랜잭션은 일시 중단시킵니다.

  `MANDATORY`는 반드시 기존 트랜잭션이 있어야 하고, 없으면 예외를 발생시킵니다.

  `NEVER`는 트랜잭션을 사용하지 않도록 강제하며, 기존 트랜잭션이 있으면 예외를 발생시킵니다.

  `NESTED`는 기존 트랜잭션 내에서 중첩 트랜잭션을 실행합니다. 부모 트랜잭션은 중첩 트랜잭션에 영향을 주지만 중첩 트랜잭션은 부모 트랜잭션에 영향을 주지 않습니다.
</details>

<details>
  <summary>영속성 컨텍스트에 대해 설명해주세요.</summary><br>

  영속성 컨텍스트는 JPA에서 엔티티를 관리하는 환경을 말합니다. 쉽게 말해서 엔티티 객체들을 저장하고 관리하는 일종의 캐시 공간이라고 생각할 수 있습니다.

  주요 특징으로는, 1차 캐시, 더티 체킹, 쓰기 지연이 있습니다.

  <b>1차 캐시</b>란 트랜잭션 내에서 엔티티 조회 시 이를 임시로 저장해두는 공간으로, 이를 통해 이후에 동일한 트랜잭션 내에서 같은 엔티티를 재조회할 경우 DB 쿼리 없이 1차 캐시에 저장되어 있는 엔티티를 재사용하며, 같은 트랜잭션 내에서 엔티티의 동일성을 보장할 수 있습니다.

  또한 영속성 컨텍스트는 1차 캐시에 엔티티를 저장할 때 스냅샷을 찍어서 저장하는데, 이를 통해 트랜잭션이 커밋될 때 1차 캐시에 저장되어 있는 엔티티의 상태와 현재 상태를 비교해서 변경사항이 있으면 자동으로 `UPDATE` 쿼리를 생성하여 실행하는 <b>더티 체킹</b> 기능을 제공합니다.

  또한 데이터베이스 쿼리를 즉시 실행하지 않고 영속성 컨텍스트 내의 <b>쓰기 지연 SQL 저장소</b>에 모아뒀다가 트랜잭션이 커밋될 때 한 번에 실행하여 네트워크 효율성을 높이는 <b>쓰기 지연</b> 기능도 제공합니다.
</details>

<details>
  <summary>JPA를 사용하는 이유에 대해 설명해주세요.</summary><br>

  가장 큰 이유는 객체지향적인 개발이 가능하다는 점입니다. 기존 JDBC를 사용할 때는 SQL 중심의 개발을 해야 했는데, JPA를 사용함으로써 객체를 다루듯이 데이터를 처리할 수 있게 되었습니다.

  그리고 기본적인 CRUD 기능을 자동으로 제공해주기 때문에 반복적인 CRUD를 직접 작성할 필요가 없어, 생산성이 향상됩니다.

  또한 형식에 맞게 메서드만 작성하면 JPA가 각 데이터베이스에 맞는 SQL을 자동으로 생성해주기 때문에 데이터베이스가 바뀌어도 애플리케이션 코드는 거의 변경할 필요가 없어, 데이터베이스 독립성과 높은 유지보수성을 얻을 수 있습니다.
</details>

<details>
  <summary>JPA와 같은 ORM을 사용하면서 쿼리가 복잡해지는 경우에는 어떻게 해결하는게 좋을까요?</summary><br>

  먼저 <b>JPQL</b>을 활용하는 방법이 있습니다. JPQL은 데이터베이스 테이블이 아닌 객체를 기준으로 쿼리를 작성하는 객체지향 쿼리 언어로, 단순한 `findBy` 메소드로는 한계가 있을 때 JPQL을 사용하면 객체지향적인 쿼리를 작성할 수 있습니다. 단, 문자열 형태이기 때문에 개발자 의존적이며, 컴파일 단계에서 타입 체크가 불가능하다는 문제가 존재합니다.

  따라서 <b>QueryDSL</b>을 사용하는 것도 좋은 방법입니다. QueryDSL은 타입 세이프하게 복잡한 동적 쿼리를 작성할 수 있고, IDE의 자동완성 기능도 활용할 수 있어서 개발 효율성이 높습니다.

  정말 복잡한 쿼리나 성능이 중요한 부분에서는 <b>네이티브 쿼리</b>를 사용합니다. `@Query` 어노테이션으로 직접 SQL을 작성할 수 있어서 데이터베이스의 고유 기능이나 복잡한 집계 쿼리도 처리할 수 있습니다.
</details>

<details>
  <summary>JPA N + 1 문제가 발생하는 이유와 이를 해결하는 방법에 대해 설명해주세요.</summary><br>

  N+1 문제는 JPA에서 1:N의 연관관계를 포함하고 있는 엔티티로부터 N에 해당하는 엔티티를 조회할 때 의도치 않은 N번의 쿼리가 추가로 실행되는 현상을 말하며, 지연 로딩이 아닌 즉시 로딩 방식을 사용할 경우 이를 방지할 수 있지만, 필요없는 데이터까지 항상 함께 가져오는 문제가 있어 권장되는 방식은 아닙니다.

  이를 해결하기 위한 가장 일반적인 방법은 <b>Fetch Join</b>을 사용하여 JPQL에서 한 번의 쿼리로 연관된 데이터를 모두 가져오는 것입니다.

  또 다른 방법으로는 `@EntityGraph` 어노테이션을 사용해서 자동으로 패치 조인이 적용되도록 하거나 `@BatchSize`를 설정해서 지연 로딩이 발생할 경우 한 번에 여러 데이터를 묶어서 조회하도록 하는 방법도 있습니다.

  > <b>일반 조인이 아닌 패치 조인을 사용하는 이유</b>  
  > <b>일반 조인</b>은 연관된 엔티티를 실제로 가져오지 않고 조건에만 사용합니다. 즉, Select 대상의 엔티티는 영속화하여 가져오지만, 조인의 대상은 영속화하여 가져오지 않기 때문에 여전히 지연 로딩 상태로 남아있게 되며, 이후에 접근하면 N+1 문제가 발생하게 됩니다.  
  > <b>패치 조인</b>은 JPA 특화 기능으로, 연관된 엔티티까지 모두 가져와서 영속성 컨텍스트에 저장합니다. 즉, Select 대상의 엔티티 뿐만 아니라 조인의 대상까지 영속화하여 가져오며, 이후에 접근하더라도 추가 쿼리가 발생하지 않습니다.
</details>

---

### 💾 Database

<details>
  <summary>인덱스에 대해 설명해주세요.</summary><br>

  인덱스는 데이터베이스에서 <b>데이터 검색 속도를 향상시키기 위해 사용하는 자료구조</b>입니다.

  쉽게 비유하면 책의 목차나 색인과 같은 개념으로, 책에서 특정 내용을 찾을 때 처음부터 끝까지 다 읽지 않고 목차를 보고 해당 페이지로 바로 가는 것처럼, 인덱스도 테이블 전체를 스캔하지 않고 원하는 데이터를 빠르게 찾을 수 있게 해줍니다.

  인덱스는 보통 B-Tree 구조로 구현되는데, 이 구조는 데이터가 정렬된 상태로 저장되어 있어서 이진 탐색처럼 빠른 검색이 가능합니다. 검색 속도가 더 빠른 해시 테이블 구조로 구현하기도 하지만, 해시 함수는 등호 연산에만 특화되어 있기 때문에 부등호 연산이 더 자주 사용되는 데이터베이스 검색의 특성상 잘 사용되지는 않습니다.

  인덱스를 사용했을 때의 장점으로는 `SELECT` 쿼리의 성능이 크게 향상됩니다. 특히 `WHERE` 절이나 `ORDER BY`, `JOIN` 조건에서 사용되는 컬럼에 인덱스가 적용되어 있으면 매우 빠른 검색이 가능합니다.

  다만, 인덱스는 별도의 저장 공간이 추가로 필요하고, 데이터가 변경될 때마다 인덱스 테이블도 함께 업데이트해야 하기 때문에 쓰기 작업의 성능은 떨어질 수 있습니다.

  그래서 인덱스는 조회가 많은 컬럼에 적용할 경우 성능 향상을 가져올 수 있지만, 변경이 많은 컬럼에 적용할 경우 오히려 성능이 떨어질 수 있어서 읽기와 쓰기 성능의 트레이드오프를 고려하여 적용해야 합니다.
</details>

<details>
  <summary>트랜잭션에 대해 설명해주세요.</summary><br>

  트랜잭션은 <b>데이터베이스에서 하나의 논리적인 작업 단위</b>를 말합니다. 여러 개의 데이터베이스 연산을 하나로 묶어서 모두 성공하거나 모두 실패하도록 보장하는 개념입니다.

  트랜잭션의 특성은 ACID(Atomicity, Consistency, Isolation, Durability)로 설명할 수 있습니다.

  <b>원자성(Atomicity)</b>은 트랜잭션 내의 모든 연산이 전부 성공하거나 전부 실패해야 한다는 특성입니다. 즉, 중간에 일부만 성공하는 상황은 있을 수 없습니다.

  <b>일관성(Consistency)</b>은 트랜잭션이 실행되기 전과 후에 데이터베이스가 일관된 상태를 유지해야 한다는 특성입니다. 즉, 데이터베이스의 무결성 제약조건이 항상 지켜져야 합니다.

  <b>격리성(Isolation)</b>은 동시에 실행되는 트랜잭션들이 서로 영향을 주지 않아야 한다는 특성입니다. 즉, 여러 사용자가 동시에 같은 데이터에 접근해도 문제가 없어야 합니다.

  <b>지속성(Durability)</b>은 트랜잭션이 성공적으로 완료되면 그 결과가 영구적으로 저장되어야 한다는 특성입니다. 즉, 시스템에 장애가 발생해도 커밋된 데이터는 보존되어야 합니다.
</details>

<details>
  <summary>트랜잭션 격리 수준에 대해 설명해주세요.</summary><br>

  격리 수준이란 여러 트랜잭션이 동시에 실행될 때 얼마나 영향을 주고받을지를 결정하는 옵션입니다.

  <b>READ_UNCOMMITED</b>는 가장 낮은 격리 수준으로, 다른 트랜잭션이 아직 커밋하지 않은 데이터도 읽을 수 있는 격리 수준입니다. 이로 인해 어떤 트랜잭에서 특정 데이터를 변경했다가 이후에 커밋하지 않고 롤백했는데, 다른 트랜잭션에서 변경된 데이터를 읽어버리는 Dirty Read 현상이 발생할 수 있습니다.

  <b>READ_COMMITD</b>는 커밋된 데이터만 읽을 수 있는 격리 수준입니다. 이를 통해 Dirty Read 현상은 방지했지만, 하나의 트랜잭션 내에서 같은 키를 가진 데이터를 여러 번 조회할 때, 그 사이에 다른 트랜잭션에서 해당 값을 변경하거나 삭제하여, 그 결과가 다르게 나타나는 Non-Repeatable Read 현상이 발생할 수 있습니다.

  <b>REPEATABLE_READ</b>는 같은 트랜잭션 내에서 같은 데이터를 여러 번 읽어도 항상 같은 결과를 보장하는 격리 수준입니다. 이를 통해 Non-Repeatable Read 현상은 방지했지만, 일정 범위의 데이터를 여러 번 조회할 때 이전 쿼리에서는 없던 유령 데이터가 다음 쿼리에서 나타나는 Phantom Read 현상이 발생할 수 있습니다.

  <b>SERIALIZABLE</b>은 가장 높은 격리 수준으로, 완벽한 읽기 일관성을 제공하여 모든 문제를 해결할 수 있지만, 동시성 처리 성능이 급격히 떨어질 수 있습니다.
</details>

<details>
  <summary>정규화에 대해 설명해주세요.</summary><br>

  정규화는 데이터베이스 설계에서 데이터의 중복을 최소화하고 무결성을 보장하기 위해 <b>테이블을 체계적으로 분해하는 과정</b>입니다. 쉽게 말해서 하나의 큰 테이블에 모든 데이터를 넣지 말고, 논리적으로 관련있는 데이터끼리 나누어서 별도의 테이블로 만드는 것입니다.

  정규화에는 여러 단계가 있는데, 실무에서는 보통 3정규형까지 적용합니다.

  <b>1정규형</b>은 각 속성이 원자값을 가지도록 테이블을 분해하는 과정입니다.

  <b>2정규형</b>은 복합 기본키의 일부에만 종속되는 속성을 제거하여, 부분 함수 종속을 제거하도록 테이블을 분해하는 과정입니다.

  <b>3정규형</b>은 기본키가 아닌 속성들 간의 종속성을 제거하여, 이행 함수 종속을 제거하도록 테이블을 분해하는 과정입니다.
</details>

<details>
  <summary>RDBMS와 NoSQL의 차이에 대해 설명해주세요.</summary><br>

  <b>RDBMS</b>는 관계형 데이터베이스로, 데이터를 테이블 형태로 저장하고 테이블 간의 관c계를 통해 데이터를 관리합니다. MySQL, PostgreSQL, Oracle 같은 것들이 여기에 해당합니다. 스키마가 고정되어 있어서 데이터 구조가 명확하고, SQL이라는 표준화된 언어를 사용합니다.

  <b>NoSQL</b>은 "Not Only SQL"의 줄임말로, 관계형 모델을 사용하지 않는 데이터베이스입니다. 문서형, 키-값형, 컬럼형 등 벤더에 따라 다양한 형태로 데이터를 관리합니다.

  둘의 가장 큰 차이점은 스키마의 유연성입니다. RDBMS는 미리 정의된 스키마를 따라야 하지만, NoSQL은 스키마가 없거나 유연해서 다양한 형태의 데이터를 저장할 수 있습니다.

  따라서 정형화된 데이터와 복잡한 관계, 강한 일관성이 필요한 경우에는 RDBMS를, 대용량 데이터 처리나 빠른 개발, 유연한 스키마가 필요한 경우에는 NoSQL을 사용하는 것이 적합합니다.
</details>

<details>
  <summary>DB Lock에 대해 설명해주세요.</summary><br>

  DB Lock은 여러 사용자가 동시에 같은 데이터에 접근할 때 데이터 무결성을 보장하기 위한 메커니즘입니다.

  <b>공유 락</b>은 읽기 작업에 사용됩니다. 여러 트랜잭션이 동시에 같은 데이터를 읽을 수는 있지만, 읽는 중에는 수정할 수 없도록 막습니다.

  <b>배타 락</b>은 쓰기 작업에 사용되는데, 한 트랜잭션이 배타 락을 걸면 해당 트랜잭션이 데이터를 완전히 독점하게 되며, 다른 트랜잭션은 그 데이터를 읽거나 쓸 수 없습니다.
</details>

<details>
  <summary>JOIN에 대해 설명해주세요.</summary><br>

  JOIN은 두 개 이상의 테이블을 연결해서 관련된 데이터를 함께 조회하는 SQL 연산입니다.

  관계형 데이터베이스에서는 데이터를 여러 테이블로 나누어 저장하기 때문에, 필요한 정보를 얻으려면 테이블들을 연결해서 조회해야 하며, 이때 사용하는 연산이 JOIN 연산입니다.
</details>

<details>
  <summary>데이터베이스 언어에 대해 설명해주세요.</summary><br>

  데이터베이스 언어란 데이터베이스를 조작하고 관리하기 위해 사용하는 언어로, 크게 세 가지로 분류됩니다.

  <b>DDL(Data Definition Language)</b>은 데이터 정의어로, 데이터베이스의 구조를 정의하고 변경하는 언어입니다. 테이블을 생성하는 `CREATE`, 테이블 구조를 수정하는 `ALTER`, 테이블을 삭제하는 `DROP` 명령어가 여기에 해당합니다.

  <b>DML(Data Manipulation Language)</b>은 데이터 조작어로, 실제 데이터를 조작하는 언어입니다. 데이터를 조회하는 `SELECT`, 데이터를 삽입하는 `INSERT`, 데이터를 수정하는 `UPDATE`, 데이터를 삭제하는 `DELETE` 명령어가 여기에 해당합니다.

  <b>DCL(Data Control Language)</b>은 데이터 제어어로, 데이터베이스에 대한 접근 권한을 관리하는 언어입니다. 권한을 부여하는 `GRANT`, 권한을 회수하는 `REVOKE` 명령어가 여기에 해당합니다.

  추가로 <b>TCL(Transaction Control Language)</b>을 별도로 분류하기도 하는데, 트랜잭션을 제어하는 언어입니다. 트랜잭션을 확정하는 `COMMIT`, 트랜잭션을 취소하는 `ROLLBACK`, 중간 저장점을 설정하는 `SAVEPOINT` 명령어가 여기에 해당합니다.
</details>

<details>
  <summary>SQL Injection에 대해 설명해주세요.</summary><br>

  SQL Injection은 공격자가 악의적인 SQL 코드를 입력해서 데이터베이스를 조작하거나 정보를 빼내는 공격 방법으로, 애플리케이션에서 사용자 입력값을 제대로 검증하지 않고 SQL 쿼리에 직접 집어 넣을 때 발생할 수 있는 보안 취약점입니다.

  이를 방어하는 가장 좋은 방법은 PreparedStatement를 사용하여, 쿼리 구조를 미리 정해놓고 데이터만 따로 전달함으로써 SQL 코드 자체가 바뀌는 것을 막는 것입니다.

  JPA와 같은 ORM을 사용하면 대부분 자동으로 방어가 되지만, 네이티브 쿼리를 쓸 때에는 반드시 PreparedStatement를 사용하거나 직접 입력값을 검증하여 방어해야 합니다.
</details>

<details>
  <summary>옵티마이저에 대해 설명해주세요.</summary><br>
  
  옵티마이저는 <b>데이터베이스에서 SQL 쿼리를 가장 효율적으로 실행할 수 있는 방법을 찾아주는 구성 요소</b>입니다.
  
  개발자가 작성한 SQL 쿼리를 받으면, 옵티마이저는 디스크 I/O, CPU 사용량, 메모리 사용량 등을 기반으로 각 실행 계획에 대해 예상되는 비용을 계산하여 가장 비용이 적게 드는 방법을 선택하여 실행합니다.

  옵티마이저가 만든 실행 계획은 `EXPLAIN` 명령어로 확인할 수 있으며, 실무에서 쿼리 성능이 느릴 때 이를 통해 실행 계획을 보고 어디서 병목이 발생하는지 분석할 수 있습니다.
</details>

<details>
  <summary>DB 튜닝에 대해 설명해주세요.</summary><br>

  DB 튜닝은 <b>데이터베이스의 성능을 최적화하는 작업</b>을 말합니다. 쿼리 실행 속도를 개선하고, 시스템 자원을 효율적으로 사용해서 전체적인 데이터베이스 성능을 향상시키는 것이 목표입니다.

  DB 튜닝은 보통 3단계로 나누어서 진행합니다.

  1단계는 <b>DB 설계 튜닝</b>입니다. 이는 데이터베이스를 구축하기 전에 테이블 구조를 잘 설계하고 적절한 정규화를 적용하는 단계로, 설계 자체가 잘못되면 나중에 아무리 튜닝을 해도 한계가 있기 때문에 가장 기본적이고 중요한 단계라고 할 수 있습니다.

  2단계는 <b>DBMS 튜닝</b>입니다. 이는 데이터베이스 자체의 환경을 최적화하는 단계로, 메모리 설정이나 버퍼 크기 조정 등을 수행합니다. 즉, 하드웨어 리소스를 효율적으로 사용할 수 있도록 데이터베이스 시스템을 조정하는 것입니다.

  3단계는 <b>SQL 튜닝</b>입니다. 이는 실제 애플리케이션에서 실행되는 SQL 쿼리를 최적화하는 단계입니다. 실행 계획을 분석해서 비효율적인 쿼리를 찾아내고, 인덱스를 추가하거나 쿼리를 재작성해서 성능을 개선합니다. 이미 운영 중인 시스템에서 성능 문제가 발생했을 때 가장 빠르게 효과를 볼 수 있는 방법이기 때문에 많이 사용합니다.
</details>

<details>
  <summary>DELETE, TRUNCATE, DROP의 차이에 대해 설명해주세요.</summary><br>

  `DELETE`는 테이블에서 특정 행이나 조건에 맞는 데이터만 삭제하는 명령어입니다. `WHERE` 절을 사용해서 원하는 데이터만 선택적으로 지울 수 있고, 삭제된 데이터는 트랜잭션 로그에 기록되기 때문에 `ROLLBACK`으로 복구가 가능합니다. 하지만 행 단위로 처리하기 때문에 대용량 데이터를 삭제할 때는 속도가 느립니다.

  `TRUNCATE`는 테이블의 모든 데이터를 한 번에 삭제하는 명령어입니다. `WHERE` 절을 사용할 수 없어서 전체 데이터만 삭제할 수 있고, 페이지 단위로 삭제하기 때문에 `DELETE`보다 훨씬 빠릅니다. 하지만 트랜잭션 로그를 최소한으로만 기록하기 때문에 구체적으로 어떤 데이터가 삭제된 것인지를 확인하기가 어려워 `ROLLBACK`이 불가능합니다.

  `DROP`은 테이블 자체를 완전히 제거하는 명령어입니다. 따라서 데이터뿐만 아니라 테이블 구조, 인덱스, 제약조건까지 모든 것이 삭제됩니다. 한 번 실행하면 복구가 불가능합니다.
</details>

<details>
  <summary>데이터베이스 클러스터링과 리플리케이션의 차이에 대해 설명해주세요.</summary><br>

  <b>클러스터링</b>은 여러 대의 DB 서버가 하나의 스토리지를 공유하면서 마치 한 대의 시스템처럼 동작하는 방식입니다. 모든 서버가 같은 스토리지를 바라보고 있어서 어느 서버에 접속해도 동일한 데이터를 볼 수 있습니다. 한 대의 서버에 장애가 발생하더라도 다른 서버가 즉시 작업을 이어받을 수 있어 고가용성을 제공하며, 기존에 하나의 DB 서버에 몰리던 부하를 여러 곳으로 분산시켜 동시에 처리함으로써 높은 성능을 제공합니다. 단, 여러 개의 서버를 동시에 운영해야 하기 때문에 그만큼 비용이 많이 들게 됩니다.

  <b>리플리케이션</b>은 여러 개의 DB를 권한에 따라 수직적인 구조로 구축하는 방식으로, 마스터 데이터베이스를 여러 슬레이브 데이터베이스에 복사하여 동기화하는 방식입니다. 보통 마스터에서는 쓰기 작업을 처리하고, 슬레이브에서는 읽기 작업을 처리해서 부하를 분산시키며, 비동기 방식으로 운영되기 때문에 지연 시간이 거의 없습니다. 단, 노드들 간의 데이터 동기화가 보장되지 않아 데이터의 일관성이 떨어질 수 있고, 마스터에 장애가 발생하면 복구 및 대처가 까다롭다는 단점이 있습니다.
</details>

<details>
  <summary>Primary Key와 Unique Key의 차이에 대해 설명해주세요.</summary><br>

  <b>Primary Key</b>는 테이블의 주된 식별자로 테이블에 딱 하나만 존재하고 NULL을 허용하지 않습니다.

  <b>Unique Key</b>도 중복을 방지하는 제약조건이지만, 테이블에 여러 개의 Unique Key가 존재할 수 있고,  NULL을 허용한다는 차이가 있습니다.
</details>

---

### 🔙 Backend

<details>
  <summary>WS와 WAS의 차이에 대해 설명해주세요.</summary><br>

  <b>WS(Web Server)</b>는 정적인 컨텐츠를 처리하는 서버로, HTTP 프로토콜을 기반으로 HTML, CSS, JavaScript, 이미지 파일 같은 정적 자원들을 클라이언트에게 전달하는 역할을 합니다.

  <b>WAS(Web Application Server)</b>는 동적인 컨텐츠를 처리할 수 있는 서버로, 사용자 요청에 따라 프로그램을 실행하고, 데이터베이스와 연동해서 비즈니스 로직을 처리한 후 결과를 생성해서 응답하는 JSP, Servlet 같은 웹 애플리케이션을 실행할 수 있는 환경을 제공합니다.
</details>

<details>
  <summary>RESTful API에 대해 설명해주세요.</summary><br>

  RESTful API란 REST(Representational State Transfer) 아키텍처의 원칙을 따르는 웹 서비스 설계 방식입니다.

  REST의 기본 개념은 자원(Resource)을 URI로 표현하고, 해당 자원에 대한 행위를 HTTP 메서드를 통해 표현하는 것이며, 즉 RESTful API란 <b>URI와 HTTP 메서드만으로도 그 목적을 이해할 수 있는 API</b>를 의미합니다.

  RESTful API는 직관적이고 이해하기 쉬워서 개발과 유지보수가 편리합니다. 다만, 명확한 표준이 존재하지 않아 일관성이 떨어질 수 있습니다.
</details>

---

### 👮🏻‍♂️ Security

<details>
  <summary>CORS에 대해 설명해주세요.</summary><br>

  CORS(Cross-Origin Resource Sharing)는 <b>다른 도메인의 리소스에 접근할 수 있게 해주는 웹 브라우저 보안 정책</b>입니다.
  
  기본적으로 웹 브라우저 상에는 동일 출처 정책(Same-Origin Policy)이 있어서 보안상 다른 도메인, 포트, 프로토콜에서는 리소스에 접근할 수 없습니다.

  CORS는 서버가 HTTP 응답 헤더에 허용할 도메인 정보를 포함해서 응답함으로써 특정 도메인에 대한 요청을 명시적으로 허가하는 방식으로 이를 해결합니다.
</details>

<details>
  <summary>대칭키 암호화와 공개키 암호화 방식에 대해 설명해주세요.</summary><br>

  <b>대칭키 암호화</b>란 암호화와 복호화에 같은 키를 사용하는 방식으로, 송신자와 수신자가 동일한 비밀키를 미리 공유해야 합니다.
  이는 알고리즘이 단순하고 속도가 매우 빨라 대용량 데이터를 빠르게 처리할 수 있다는 장점이 있지만, 처음에 키를 공유하는 과정에서 비밀키가 노출될 수 있다는 문제가 있습니다.

  <b>공개키 암호화</b>란 암호화와 복호화에 서로 다른 두 개의 키를 사용하는 방식으로, 공개키와 개인키 한 쌍을 만들어서, 공개키로 암호화하고 개인키로 복호화하는 방식입니다.
  이는 사전에 비밀키를 공유할 필요가 없기 때문에, 대칭키 암호화 방식에서 발생했던 키 유출 문제를 해결할 수 있습니다. 단, 연산이 매우 느려서 대용량 데이터 처리에는 부적합하다는 문제가 있습니다.

  따라서 일반적으로 두 방식을 조합해서 사용합니다. 먼저 공개키 암호화로 대칭키를 안전하게 전송하고, 실제 데이터는 대칭키 암호화 방식으로 전달하는 하이브리드 방식을 많이 사용하며 HTTPS도 바로 이런 방식입니다.
</details>

<details>
  <summary>JWT에 대해 설명해주세요.</summary><br>
  
  JWT는 웹에서 정보를 안전하게 전송하기 위한 토큰 기반의 인증 방식으로, Header, Payload, Signature로 구성되어 있습니다.

  <b>Header</b>에는 토큰 타입과 암호화 알고리즘 정보가 들어가고, <b>Payload</b>에는 실제 전달하려는 데이터(사용자 ID, 권한 등)가 들어갑니다. <b>Signature</b>는 토큰이 변조되지 않았음을 검증하기 위한 서명 부분입니다. 이 세 부분이 점(`.`)으로 구분되어 하나의 문자열로 만들어집니다.

  이를 통해 얻는 가장 큰 이점은 서버가 클라이언트의 상태를 저장하지 않는다는 점입니다. 기존의 세션 방식은 서버에서 세션 정보를 저장해야 했는데, JWT는 토큰 자체에 모든 정보가 들어있어서 서버에서 별도로 저장할 필요가 없어 서버의 부담을 줄일 수 있습니다.

  다만, 토큰이 탈취되면 만료될 때까지 계속 사용될 수 있고, 토큰 크기가 세션 ID보다 크기 때문에 네트워크 오버헤드가 커질 수 있습니다.
</details>

<details>
  <summary>OAuth에 대해 설명해주세요.</summary><br>

  OAuth는 사용자가 특정 웹 서비스의 계정을 직접 생성하지 않고, 네이버, 구글과 같은 기존 Third Party Provider 계정을 통해 해당 웹 서비스의 자원에 접근할 수 있도록 허가해주는 인증 프토로콜입니다.

  OAuth를 사용하면 사용자 로그인 편의성을 개선할 수 있고, 사용자 계정 관리에 대한 부담을 줄일 수 있다는 장점이 있습니다.
</details>

<details>
  <summary>XSS에 대해 설명해주세요.</summary><br>

  XSS는 Cross-Site Scripting의 줄임말로, 웹 페이지에 악성 스크립트를 삽입해서 다른 사용자들에게 실행시키는 공격 방법입니다.

  공격자가 웹 페이지에 악의적인 JavaScript 코드를 주입하면, 해당 페이지를 방문하는 사용자들의 브라우저에서 그 스크립트가 자동으로 실행되어 쿠키나 세션 정보를 탈취하거나 사용자를 다른 사이트로 리다이렉트시키는 방식입니다.

  이는 입력값 검증과 출력값 이스케이프 처리를 통해 방어할 수 있습니다. CSP 헤더를 설정해서 스크립트 실행을 제한하고, HttpOnly 쿠키를 사용해서 쿠키에 접근하지 못하게 하는 것도 효과적입니다.

  > <b>CSP(Content Security Policy) 헤더</b>  
  > CSP 헤더는 웹 페이지에서 실행될 수 있는 리소스(Script, Style, 이미지 등)의 출처를 제한하는 보안 정책을 정의하는 HTTP 응답 헤더입니다.  
  > 이는 브라우저에게 "에 웹페이지에서는 특정 출처의 리소스만 로드하고 실행해도 된다"고 알려주는 역할을 합니다.

  > <b>HttpOnly 쿠키</b>  
  > HttpOnly 쿠키는 JavaScript를 통한 접근을 차단하는 보안 속성이 설정된 쿠키입니다.  
  > 쿠키를 생성할 때 HttpOnly 플래그를 설정하면 브라우저는 해당 쿠키를 HTTP 요청 시에만 자동으로 전송하며, JavaScript에서는 접근 불가능합니다.
</details>

<details>
  <summary>CSRF에 대해 설명해주세요.</summary><br>

  CSRF는 Cross-Site Request Forgery의 줄임말로, 사용자가 이미 로그인한 사이트에서 사용자의 권한을 악용하여 사용자가 의도하지 않은 요청을 악의적으로 실행시키는 공격 방법입니다.

  이는 서버에서 예측 불가능한 CSRF 토큰을 생성하여 폼(Form)에 숨겨두고, 요청이 올 때마다 이 토큰이 일치하는지 확인하는 과정을 통해 방어할 수 있습니다.
</details>

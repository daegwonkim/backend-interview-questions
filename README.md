<div align="center">
  <a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.demolab.com?font=Black+Han+Sans&size=40&duration=3000&pause=1000&color=0EBB12&center=true&vCenter=true&width=450&lines=%EB%B0%B1%EC%97%94%EB%93%9C+%EA%B0%9C%EB%B0%9C%EC%9E%90+%EB%A9%B4%EC%A0%91+%EC%A7%88%EB%AC%B8+%EC%A0%95%EB%A6%AC" alt="Typing SVG" /></a>  
</div>

## 🎯 Introduction
백엔드 개발 면접을 준비하면서 정리한 질문과 답변 모음집입니다.  
CS, 프로그래밍 언어, 프레임워크, 데이터베이스, Web, 보안 관련 내용을 다룹니다.  
주관적인 내용을 포함하고 있습니다.

## 📌 Index
- [CS](#-cs)
  - [운영체제](#운영체제)
  - [네트워크](#네트워크)
  - [자료구조/알고리즘](#자료구조알고리즘)
- [Programming Language](#%E2%80%8D-programming-language)
  - [공통](#공통)
  - [Java](#java)
- [Architecture](#-architecture)
- [Framework](#-framework)
- [Database](#-database)
- [Web](#-web)
- [Security](#-security)

## 💡 Questions
### 🖥 CS
#### 운영체제
<details>
  <summary>프로세스와 스레드의 차이에 대해 설명해주세요.</summary><br>
  
  프로세스와 스레드는 운영체제에서 <b>실행의 단위</b>를 나타내는 개념입니다.<br>
  
  <b>프로세스</b>는 현재 실행 중인 프로그램을 의미하고, 각 프로세스는 독립적인 메모리 공간을 가지고 있으며, 다른 프로세스와 완전히 분리되어 있습니다.<br>
  
  <b>스레드</b>는 프로세스 내에서 실행되는 작업의 단위이며, 하나의 프로세스 안에 여러 개의 스레드가 있을 수 있습니다. 스레드들은 같은 프로세스의 메모리 공간(스택 영역 제외)을 공유합니다.<br>

  주요 차이점을 요약하면 다음과 같습니다.
  1. 프로세스는 독립적인 메모리 공간을 가지지만 스레드는 코드, 데이터, 힙 영역을 공유하고 스택 영역만 따로 갖습니다.<br>
  2. 프로세스 간에는 서로 통신을 통해서 자원을 공유하고 데이터를 주고받아야 하지만, 스레드는 공유 메모리를 통해서 쉽게 데이터를 공유할 수 있습니다.<br>
  3. 프로세스는 하나의 프로세스가 죽어도 다른 프로세스에 영향을 주지 않지만, 스레드는 하나에 문제가 생기면 해당 스레드를 포함하고 있는 전체 프로세스가 영향을 받을 수 있습니다.
</details>
<details>
  <summary>스레드를 사용하는 이유에 대해 설명해주세요.</summary><br>

  스레드를 사용하는 가장 큰 이유는 <b>동시성을 통한 성능 향상</b>입니다.<br>

  단일 스레드로는 하나의 작업이 끝날 때까지 다른 작업을 할 수 없지만, 멀티 스레드를 사용하면 여러 작업을 동시에 처리할 수 있어 전체적인 처리량이 증가합니다.<br>

  또 파일 읽기, 네트워크 통신, 데이터베이스 쿼리와 같은 I/O 작업은 시간이 오래 걸리는데, 이때 다른 스레드가 CPU를 사용해서 다른 작업을 처리할 수 있어서 <b>I/O 블로킹 문제</b>도 해결할 수 있습니다.
</details>
<details>
  <summary>스레드는 최대한 많이 생성해서 사용하면 좋을까요?</summary><br>

  Java에서 각 스레드는 기본적으로 1~2MB 정도의 스택 메모리를 할당받습니다. 이는 결코 적은 양이 아니기 때문에 스레드를 무작정 많이 생성하면 추후에 <b>메모리 부족 현상</b>이 발생할 수 있습니다.<br>

  또한 CPU 코어의 수는 한정적인데 스레드 수만 많아지면 OS가 계속해서 스레드를 교체하면서 실행해야 하므로, 이 과정에서 발생하는 <b>컨텍스트 스위칭 오버헤드</b>로 인해 성능이 나빠질 수 있습니다.<br>

  더불어 스레드를 만들고 없애는 작업 자체도 시스템 리소스를 많이 사용하기 때문에 <b>스레드 생성 및 소멸 비용</b>도 무시할 수 없습니다.<br>

  따라서 스레드를 사용할 때에는 <b>Thread Pool</b>을 사용해서 적절한 개수의 스레드를 미리 생성해두고 재사용하는 방식을 주로 사용합니다.<br>

  결국에는 적절한 수가 핵심이고, 모니터링을 통해 최적의 스레드 수를 찾아가는 것이 중요합니다.
</details>
<details>
  <summary>메모리 구조에 대해 설명해주세요.</summary><br>
  
  메모리 구조는 크게 코드 영역, 데이터 영역, 힙 영역, 스택 영역으로 구분됩니다.<br>
  
  <b>코드 영역</b>은 실행할 프로그램의 코드가 저장되는 영역으로, 컴파일된 기계어 명령어들이 저장됩니다.<br>
  사용자가 프로그램 실행 명령을 내리면 OS에서는 디스크에서 메모리의 코드 영역으로 실행 코드를 올리게 되고, CPU는 코드 영역에 저장된 명령어를 하나씩 실행하게 됩니다.<br>

  <b>데이터 영역</b>은 프로그램 실행에 필요한 전역 변수와 정적 변수가 저장되는 영역입니다.<br>
  
  <b>힙 영역</b>은 동적으로 할당되는 메모리 공간으로, `malloc()`이나 `new`와 같은 함수로 런타임에 메모리를 요청할 경우 사용됩니다.<br>
  
  <b>스택 영역</b>은 함수 호출과 관련된 데이터가 저장되는 공간으로, 매개 변수나 지역 변수와 같은 데이터가 스택 프레임의 형태로 저장됩니다.<br>
  함수가 호출되면 스택에 스택 프레임이 쌓이고, 함수가 종료되면 스택 프레임이 제거되는 방식으로 동작합니다.
</details>
<details>
  <summary>컨텍스트 스위칭에 대해 설명해주세요.</summary><br>

  컨텍스트 스위칭이란 <b>CPU가 현재 실행중인 프로세스나 스레드의 실행을 중단하고 다른 프로세스나 스레드로 전환하는 과정</b>을 말합니다.<br>

  현재 실행중인 프로세스의 상태를 <b>PCB(Process Control Block)</b>에 저장하고, 다음에 실행할 프로세스의 상태를 PCB에서 불러와서 CPU 레지스터에 복원하는 방식으로 동작합니다.<br>

  컨텍스트 스위칭이 발생하는 기준은 다음과 같습니다.
  1. 시분할 시스템에서 타임 슬라이스가 끝난 경우
  2. I/O 작업으로 프로세스가 대기 상태에 들어간 경우
  3. 우선순위가 높은 프로세스가 대기열에 들어선 경우
  4. 프로세스가 종료된 경우
</details>
<details>
  <summary>CPU 스케줄링 알고리즘에 대해 설명해주세요.</summary><br>

  CPU 스케줄링 알고리즘이란 <b>여러 프로세스가 CPU를 사용하려고 할 때 어떤 순서로 CPU를 할당할지 결정하는 방법</b>을 말합니다.<br>

  <b>FCFS(First Come First Served) 스케줄링 기법</b>은 먼저 도착한 프로세스부터 처리하는 가장 간단한 방식으로, 공정하지만 작업 시간이 긴 프로세스가 먼저 도착하면 뒤의 짧은 작업들이 오래 기다려야 하는 <b>콘보이 현상</b>이 발생할 수 있습니다.

  <b>SJF(Shortest Job First) 스케줄링 기법</b>은 실행 시간이 가장 짧은 프로세스부터 처리하는 방식으로, 평균 대기 시간을 최소화할 수 있지만, 프로세스의 실행 시간을 미리 알기가 어렵고 실행 시간이 긴 프로세스의 경우에는 계속 실행이 지연되어 <b>기아 현상</b>이 발생할 수 있습니다.<br>

  <b>Round Robin 스케줄링 기법</b>은 각 프로세스에게 동일한 시간 할당량(타임 슬라이스)을 주고 돌아가면서 실행시키는 방식으로, 응답시간이 좋고 공정하지만 타임 슬라이스가 너무 짧으면 <b>컨텍스트 스위칭 오버헤드</b>로 인해 성능에 문제가 생길 수 있습니다.<br>

  <b>우선순위 스케줄링 기법</b>은 각 프로세스에 우선순위를 부여해서 높은 우선순위의 프로세스부터 처리하는 방식으로, 중요한 작업을 먼저 처리할 수 있지만 낮은 우선순위 프로세스의 경우 계속 실행이 지연되어 <b>기아 현상</b>이 발생할 수 있습니다.<br>

  <b>다단계 피드백 큐 스케줄링 기법</b>은 여러 개의 큐를 두고 프로세스의 행동에 따라 우선순위를 동적으로 조정하는 방식으로, CPU 집약적인 프로세스는 낮은 우선순위로, I/O 집약적인 프로세스는 높은 우선순위로 관리하며 CPU 실행 효율성을 높이는 기법입니다.

  > <b>콘보이 현상</b><br>
  > 콘보이 현상이란 작업 시간이 긴 프로세스에 의해 다른 프로세스의 실행이 전부 늦춰지는 현상을 말합니다.<br>
  > FCFS 스케줄링은 <b>비선점형 스케줄링 방식</b>으로, I/O 작업으로 인해 프로세스가 대기 상태로 전환되거나 프로세스가 완전히 종료되기 전까지는 다른 프로세스를 실행할 수 없기 때문에 이러한 현상이 발생할 수 있습니다.

  > <b>기아 현상</b><br>
  > 기아 현상이란 특정 프로세스가 계속해서 자원을 할당받지 못해 무한정 기다리게 되는 상황을 말합니다.<br>
  > 즉, SJF나 우선순위 스케줄링 방식에서 우선순위가 높은 프로세스들이 계속 들어오면서 우선순위가 낮은 프로세스는 영원히 실행되지 못하는 것을 의미하며, 이에 대한 가장 일반적인 해결책은 프로세스가 오래 기다릴수록 우선순위를 점진적으로 높여주는 <b>에이징(aging) 기법</b>을 사용하는 것입니다.
</details>
<details>
  <summary>선점형 스케줄링과 비선점형 스케줄링의 차이에 대해 설명해주세요.</summary><br>

  선점형 스케줄링과 비선점형 스케줄링은 <b>현재 실행중인 프로세스로부터 CPU를 강제로 빼앗을 수 있는지에 대한 개념</b>을 말합니다.<br>

  <b>비선점형 스케줄링</b>에서는 한 번 CPU를 할당받은 프로세스는 작업이 완료되거나 자발적으로 CPU 반납하지 않는 이상 계속 실행됩니다.<br>
  즉, 운영체제가 강제로 CPU를 빼앗을 수 없으며, 대표적인 예로 FCFS, SJF 스케줄링이 있습니다.<br>
  비선점형 스케줄링은 구현이 간단하고 컨텍스트 스위칭 오버헤드가 적지만, 작업 시간이 긴 프로세스가 CPU를 독점할 경우 응답 시간이 나빠질 수 있습니다.<br>

  <b>선점형 스케줄링</b>에서는 운영체제가 필요에 따라 현재 실행중인 프로세스로부터 CPU를 강제로 빼앗을 수 있습니다.<br>
  타임 슬라이스가 끝나거나 더 높은 우선순위 프로세스가 나타나면 현재 프로세스를 중단시키고 다른 프로세스를 실행하는 방식으로, 대표적인 예로 Round Robin이나 우선순위 스케줄링이 있습니다.<br>
  선점형 스케줄링은 응답 시간이 좋고 공정하지만, 컨텍스트 스위칭 오버헤드가 커질 수 있습니다.
</details>
<details>
  <summary>동기와 비동기의 차이에 대해 설명해주세요.</summary><br>

  동기와 비동기는 <b>작업의 실행 방식과 결과를 기다리는 방법에 대한 개념</b>을 말합니다.<br>

  <b>동기(Synchronous)</b>란 작업을 순차적으로 실행하는 방식으로, 하나의 작업이 완전이 끝날 때까지 기다렸다가 다음 작업을 실행합니다.<br>
  동기 방식은 코드가 직관적이고 이해하기 쉽지만, 느린 작업이 포함되어 있으면 전체적인 성능에 악영향을 미칠 수 있다는 특징을 갖고 있습니다.<br>

  <b>비동기(Asynchronous)</b>란 작업을 시작한 후 해당 작업에 대한 완료를 기다리지 않고 또 다른 작업 요청을 받아서 처리하는 방식으로, 나중에 작업이 완료된 것이 감지되면 그때 결과를 처리합니다.<br>
  비동기 방식은 효율적이고 응답성이 좋지만, 코드가 복잡해지고 디버깅이 어려워질 수 있다는 특징을 갖고 있습니다.
</details>
<details>
  <summary>Blocking I/O와 Non-blocking I/O의 차이에 대해 설명해주세요.</summary><br>

  Blocking I/O와 Non-blocking I/O는 <b>입출력 작업을 처리하는 방식에 대한 개념</b>을 말합니다.<br>

  <b>Blocking I/O</b>는 I/O 작업을 요청한 후 그 작업이 완료될 때까지 스레드가 대기하는 방식으로, 예를 들어 파일을 읽는 함수를 호출하면 파일 읽기가 완전히 끝날 때까지 해당 스레드는 다른 작업을 수행할 수 없게 됩니다.<br>
  코드는 간단하지만 효율성이 떨어진다는 특징을 갖고 있습니다.<br>

  <b>Non-blocking I/O</b>는 I/O 작업을 요청한 후 스레드가 커널로부터 바로 제어권을 반환 받아서 다른 작업을 처리할 수 있는 방식으로, 이후 polling이나 커널의 system call을 통해 작업이 완료되었음을 확인합니다.<br>
  Blocking 방식에 비해 효율적이지만, polling 방식을 사용할 경우 CPU 사용량이 늘어날 수 있습니다.
</details>
<details>
  <summary>멀티 스레드 프로그래밍에 대해 설명해주세요.</summary><br>

  멀티 스레드 프로그래밍이란 <b>하나의 프로세스 내에서 여러 개의 스레드를 생성하여 작업을 병렬로 처리하는 프로그래밍 기법</b>입니다.<br>

  이때 각 스레드는 같은 프로세스의 메모리 공간(스택 영역 제외)을 공유하며, 독립적인 실행 흐름을 갖습니다.<br>

  멀티 스레드를 사용하면 CPU 코어를 효율적으로 활용할 수 있고, I/O 작업 중에도 다른 스레드가 작업을 계속할 수 있어서 전체적인 처리량이 늘어납니다.<br>

  다만, 여러 스레드가 공유 데이터에 동시에 접근하는 경우에는 예상치 못한 결과가 나오거나(Race Condition), 교착상태가 발생할 수도 있습니다.<br>

  따라서 멀티 스레드 환경에서는 뮤텍스, 세마포어 같은 동기화 도구를 사용해서 임계 영역에는 한 번에 하나의 스레드만 접근할 수 있도록 동기화 처리를 하는 것이 중요합니다.
</details>
<details>
  <summary>멀티 스레드 환경에서의 동기화 기법에 대해 설명해주세요.</summary><br>

  멀티 스레드 환경에서 공유 자원에 대한 접근을 제어해서 데이터의 일관성을 보장하는 방법으로 사용되는 도구는 크게 3가지가 있습니다.<br>

  <b>뮤텍스(Mutex)</b>는 가장 기본적인 동기화 도구로, <b>한 번에 하나의 스레드</b>만 임계 영역에 접근할 수 있도록 합니다.<br>
  즉, 임계 영역에 진입할 수 있는 열쇠가 하나 뿐이며, 특정 스레드가 락을 획득하면 다른 스레드들은 락이 해제될 때까지 기다려야 합니다.<br>

  <b>세마포어는(Semaphore)</b>는 뮤텍스를 일반화한 개념으로, <b>동시에 접근할 수 있는 스레드의 개수를 제한</b>하는 방식입니다.<br>
  즉, 정해진 카운트에 따라 임계 영역에 동시에 접근할 수 있는 스레드의 개수가 정해지며, 뮤텍스와 마찬가지로 락을 획득하고 해제하는 작업을 통해 동기화가 이루어집니다.<br>

  <b>모니터(Monitor)</b>는 뮤텍스에 <b>조건 변수</b>를 추가한 동기화 도구로, 조건 변수란 특정 조건이 참이 될 때까지 스레드를 대기시키는 도구를 말합니다. (주로 생산자-소비자 문제에서 버퍼가 비어있을 때 소비자를 기다리게 하는 용도로 많이 사용됨)<br>
  따라서 모니터는 단순한 락 획득/해제 뿐만 아니라 조건 변수를 통한 조건 기반 대기와 통지 매커니즘을 제공하여 더 정교한 제어가 가능합니다.
</details>
<details>
  <summary>레이스 컨디션에 대해 설명해주세요.</summary><br>

  레이스 컨디션(Race Condition)이란 <b>둘 이상의 프로세스나 스레드가 공유 자원에 동시에 접근하여 변경하려고 할 때, 실행 순서에 따라 예상치 못한 결과가 나오는 현상</b>을 말합니다.<br>

  레이스 컨디션의 가장 큰 문제는 항상 발생하는 것이 아니라 타이밍에 따라 간헐적으로 발생한다는 점으로, 찾기도 어렵고 재현하기도 힘들어서 멀티 스레드 환경에서 가장 조심해야하는 부분입니다.
</details>
<details>
  <summary>교착상태에 대해 설명해주세요.</summary><br>

  교착상태(Deadlock)란 <b>두 개 이상의 프로세스나 스레드가 서로가 가진 자원을 기다리면서 무한정 대기하는 상태</b>를 말합니다.<br>

  교착 상태는 프로세스나 스레드가 서로 자원을 점유하려고 하는 과정에서 아래 네 가지 필요조건이 동시에 충족될 경우 발생합니다.
  - <b>상호배제</b>: 자원은 한 번에 하나의 프로세스만 사용할 수 있다.
  - <b>비선점</b>: 다른 프로세스의 자원을 강제로 빼앗을 수 없다.
  - <b>점유와 대기</b>: 자원을 할당받은 상태에서 또 다른 자원을 기다리는 상태
  - <b>순환 대기</b>: 프로세스들이 원형으로 서로의 자원을 기다리는 상태

  교착상태를 해결하기 위한 방법으로는 크게 3가지가 있습니다.
  - <b>교착상태 예방</b>: 교착상태가 발생하는 조건 중 하나라도 충족하지 않도록 설계하는 방법
  - <b>교착상태 회피</b>: 교착 상태가 발생할 가능성을 배제하지 않고 자원을 적당히 할당하다가 교착상태의 위험이 있을 때에는 자원을 할당하지 않는 방법. 즉, 안전한 상태에서만 자원을 할당하는 방법으로, 대표적으로는 <b>은행원 알고리즘(Banker's Algorithm)</b>이 있다.
  - <b>검출 후 회복</b>: 자원을 제약 없이 할당하다가 교착상태가 발생하면 해결하는 방법
</details>
<details>
  <summary>가상 메모리에 대해 설명해주세요.</summary><br>

  가상 메모리란 <b>실행하고자 하는 프로그램의 일부만 메모리에 적재하는 메모리 관리 기법</b>입니다.<br>

  이를 통해 실제 메모리 크기보다 큰 프로그램도 실행할 수 있고, 여러 프로세스가 메모리를 효율적으로 공유할 수 있습니다.<br>

  주로 프로세스의 논리 주소 공간과 메모리의 물리 주소 공간을 페이지와 프레임이라고 하는 일정한 단위로 나누어서 관리하는 <b>페이징 기법</b>을 사용하여 구현하며, 운영체제는 물리 메모리와 디스크 간에 페이지를 교체하면서 가상 메모리 시스템을 구현합니다.<br>

  이때 보편적으로 사용되는 페이지 교체 알고리즘은 <b>LRU(Least Recently Used)</b> 알고리즘으로, 이는 실제 메모리 상의 페이지들 중에서 가장 오랫동안 사용되지 않은 페이지를 교체하는 방식입니다.

  > <b>논리 주소와 물리 주소</b><br>
  > 논리 주소와 물리 주소는 메모리 관리 측면에서 사용되는 두 가지의 다른 주소 체계입니다.<br>
  > <b>논리 주소(가상 주소)</b>는 프로세스가 바라보는 논리적인 주소로, 프로세스 입장에서는 항상 0번지부터 시작하는 연속된 메모리 공간을 가진 것처럼 보입니다.<br>
  > <b>물리 주소</b>는 하드웨어가 실제로 접근하는 메모리의 물리적인 주소를 말합니다.<br>
  > CPU는 논리 주소로 메모리에 접근하며, 이 논리 주소는 <b>MMU(Memory Management Unit)</b>에 의해 물리 주소로 변환되어 실제 메모리 주소에 접근하게 됩니다.

  > <b>페이지 폴트(Page Fault)</b><br>
  > 페이지 폴트란 <b>프로세스가 접근하려는 페이지가 가상 메모리에는 존재하지만, 물리 메모리에는 존재하는 않을 때 발생하는 예외 상황</b>을 말합니다.<br>
  > 페이지 폴트가 발생하면 운영체제는 디스크에서 해당 페이지를 찾아서 메모리로 가져오는 과정을 거치게 되며, 이때 디스크 I/O가 발생하므로 페이지 폴트가 자주 발생하는 경우 시스템 성능이 크게 떨어질 수 있습니다.
</details>
<details>
  <summary>캐시에 대해 설명해주세요.</summary><br>

  캐시(Cache)란 <b>자주 사용되는 데이터를 가까운 저장소에 임시로 보관해서 시스템의 성능을 향상시키는 기법</b>입니다.<br>

  캐시 저장소는 CPU와 가깝기 때문에 메모리나 디스크에서 데이터를 읽는 것보다 훨씬 빨라, 자주 사용하는 데이터의 경우에는 캐시에 이를 저장하고 읽는 방식으로 성능을 높일 수 있습니다.<br>

  캐시에 저장될 데이터는 아래와 같은 기준에 따라 결정됩니다.
  - <b>시간 지역성</b>: 어떤 데이터가 최근에 사용되었다면, 가까운 미래에 다시 사용될 가능성이 높다는 원리
  - <b>공간 지역성</b>: 특정 데이터에 접근할 때, 그 데이터와 메모리상에서 인접한 다른 데이터도 함께 접근될 가능성이 높다는 원리
</details>

#### 네트워크
<details>
  <summary>OSI 7 계층에 대해 설명해주세요.</summary><br>

  OSI 7 계층은 네트워크 통신 과정을 7개의 단계로 나누어서 표준화한 네트워크 참조 모델입니다.<br>

  <b>1계층은 물리 계층(Physical Layer)</b>으로, 0과 1의 비트를 전기 신호로 변환하여 전송하는 계층입니다.<br>
  물리 계층에는 주소 개념이 없으며 송수신만 이루어질 뿐 전송되는 데이터에 대해 어떠한 조작이나 판단도 하지 않습니다.<br>
  케이블, 허브, 리피터 같은 물리적 장비들이 여기에 해당합니다.<br>

  <b>2계층은 데이터 링크 계층(Data Link Layer)</b>으로, 같은 네트워크(LAN) 내에 있는 호스트 간의 데이터 전송을 담당합니다.<br>
  데이터링크 계층에는 주소 개념이 있으며, MAC 주소를 사용해서 프레임 단위로 데이터를 전송합니다. 스위치, 브리지가 이 계층에서 동작합니다.<br>
  
  <b>3계층은 네트워크 계층(Network Layer)</b>으로, LAN을 넘어서 서로 다른 네트워크 간의 경로를 찾아 통신할 수 있도록 하는 계층입니다.<br>
  여기에서는 IP 주소를 사용해서 패킷을 목적지까지 라우팅하며, 라우터가 이 계층에서 작동하고, 대표적인 프로토콜로 IP 프로토콜, ARP 프로토콜이 있습니다.<br>
  
  <b>4계층은 전송 계층(Transport Layer)</b>으로, 애플리케이션 간 데이터 전송을 담당합니다.<br>
  포트 번호를 사용해서 네트워크 상의 애플리케이션을 식별하여 어디에 데이터를 전달할지 결정하며, TCP와 UDP가 이 계층의 대표적인 프로토콜입니다. <br>
  
  <b>5계층은 세션 계층(Session Layer)</b>으로, 애플리케이션 간의 통신에서 세션을 관리하는 계층이며, 연결 설정, 유지, 종료 및 동기화 기능을 제공합니다.<br>
  
  <b>6계층은 표현 계층(Presentation Layer)</b>으로, 애플리케이션 간의 통신에서 메시지 포맷을 관리하는 계층이며, 암호화, 압축, 인코딩 같은 작업을 수행합니다.
  
  <b>7계층은 응용 계층(Application Layer)</b>으로, 사용자와 직접 상호작용하는 계층이며, 애플리케이션 목적에 맞는 통신 방법을 제공합니다.<br>
  HTTP, FTP, SMTP, DNS 같은 프로토콜들이 이 계층에서 동작합니다.<br>
  
  이렇계 네트워크를 설계하면, 각 계층이 독립적으로 동작하여 하나의 계층에 문제가 생겨도 다른 계층에 영향을 주지 않고, 네트워크 문제가 발생했을 때 이를 체계적으로 분석할 수 있습니다.
</details>
<details>
  <summary>TCP와 UDP에 대해 설명해주세요.</summary><br>

  TCP와 UDP는 전송 계층에서 사용되는 두 가지 프로토콜로, <b>데이터 전송 방식</b>에서 차이가 있습니다.<br>

  <b>TCP(Transmission Control Protocol)</b>는 <b>연결 지향적 프로토콜</b>로, 데이터를 전송하기 전에 먼저 연결을 설정합니다.<br>
  TCP는 3-way handshake를 통해 연결을 맺고, 4-way handshake로 연결을 종료합니다.<br>
  TCP의 가장 큰 특징은 신뢰성으로, 데이터가 순차적으로 전달되는 것을 보장하고, 오류 제어 기능을 통해 패킷이 손실되면 재전송하여 모든 데이터가 정확하게 도작하도록 보장합니다. 또한 흐름 제어와 혼잡 제어 기능을 통해 네트워크 상황에 맞게 전송 속도를 조절할 수 있습니다.<br>

  <b>UDP(User Datagram Protocol)</b>는 <b>비연결 지향적 프로토콜</b>로, 연결 설정 과정 없이 바로 데이터를 전송합니다.<br>
  때문에 속도가 빠르고 오버헤드가 적지만, 신뢰성은 보장하지 않습니다. 즉, 패킷이 순서대로 도착하지 않을 수 있고, 손실될 수도 있습니다.<br>

  따라서 TCP는 이메일, 파일 전송처럼 데이터의 정확성이 중요한 곳에 주로 사용되고, UDP는 실시간 게임이나 동영상 스트리밍처럼 속도가 중요하고 약산의 손실은 허용할 수 있는 경우에 주로 사용됩니다.
</details>
<details>
  <summary>TCP의 3-way handshake, 4-way handshake에 대해 설명해주세요.</summary><br>

  <b>3-way handshake</b>는 TCP 통신에서 데이터를 전송하기 전에 클라이언트와 서버가 연결을 수립하는 과정으로, 아래 세 단계를 거칩니다.
  1. 클라이언트가 서버에게 연결 요청의 의미로 `SYN` 세그먼트를 전송합니다.
  2. 서버는 연결 요청에 대한 확인의 의미로 `SYN-ACK` 세그먼트를 응답합니다.
  3. 클라이언트는 서버의 응답에 대한 확인의 의미로 `ACK` 세그먼트를 서버로 보내며 최종적으로 연결이 수립됩니다.

  <b>4-way handshake</b>는 TCP 통신에서 연결을 종료하는 과정으로, 아래 네 단계를 거칩니다.
  1. 클라이언트가 서버에게 연결 종료 요청의 의미로 `FIN` 세그먼트를 전송합니다.
  2. 서버는 종료 요청에 대한 확인의 의미로 `ACK` 세그먼트를 클라이언트에게 응답합니다. (서버에서 아직 보낼 데이터가 남아있는 경우에도 `ACK` 세그먼트를 선응답합니다.)
  3. 서버는 모든 데이터 전송을 마친 후 서버쪽 연결 종료의 의미로 `FIN` 세그먼트를 클라이언트에게 전송합니다.
  4. 클라이언트는 서버쪽 연결 종료 확인의 의미로 `ACK` 세그먼트를 서버로 보내며 최종적으로 연결이 종료됩니다.
</details>
<details>
  <summary>HTTP와 HTTPS의 차이에 대해 설명해주세요.</summary><br>

  HTTP와 HTTPS는 웹에서 데이터를 주고받기 위한 프로토콜이며, <b>보안적인 측면</b>에서 차이가 있습니다.<br>

  <b>HTTP</b>는 애플리케이션 레벨의 요청-응답 기반 프로토콜로, 상태를 유지하지 않는 Stateless 프로토콜이며, TCP/IP 위에서 동작합니다.<br>
  평문 데이터를 전송하는 프로토콜이므로 클라이언트와 서버 간에 주고받는 모든 정보가 그대로 노출되어 보안에 취약합니다.<br>

  <b>HTTPS</b>는 HTTP에 <b>SSL/TLS 보안 계층</b>을 추가한 프로토콜로, 모든 데이터가 암호화되어 전송됩니다. 따라서 HTTP와 달리 중간에 가로채로 그 내용을 알 수 없습니다.
</details>
<details>
  <summary>SSL/TLS handshake에 대해 설명해주세요.</summary><br>

  SSL/TLS handshake는 클라이언트와 서버가 보안 연결을 설정하는 과정입니다.<br>
  1. 클라이언트가 서버에게 연결 요청을 보내면서 자신이 지원하는 TLS 버전, 사용 가능한 암호화 알고리즘 목록, 키 생성에 필요한 난수 등을 전송합니다.
  2. 서버는 클라이언트가 제안한 암호화 방식 중 하나를 선택하여 응답하고, 이후 서버의 공개키와 인증기관(CA, Certificate Authority)의 서명이 들어있는 인증서를 클라이언트에게 전송합니다.
  3. 클라이언트는 서버로부터 전달받은 인증서가 신뢰할 수 있는 인증서인지 검증합니다. 인증서는 CA의 개인키로 서명되어 있고, 클라이언트는 이를 운영체제나 브라우저에 미리 내장되어 있는 CA의 공개키를 통해 검증합니다.
  4. 이후 클라이언트는 서버의 공개키를 통해 통신에 사용할 비밀키를 암호화하여 서버에 전송하고, 서버는 이를 개인키로 확인합니다.
  5. 클라이언트와 서버 모두 비밀키와 난수를 조합하여 대칭키를 생성하고, 이후에 이루어지는 모든 통신은 이 대칭키로 암호화하여 전송합니다.

  > <b>SSL/TLS handshake에서 대칭키 암호화와 공개키 암호화를 복합적으로 사용하는 이유</b><br>
  > 대칭키 암호화와 공개키 암호화 방식을 복합적으로 활용하는 키를 <b>세션키</b>라고 합니다.<br>
  > 이를 통해 대칭키 암호화 방식의 보안 문제와, 공개키 암호화 방식의 성능 문제를 해결하고 각각의 장점만을 활용한 암호화 통신이 가능합니다.
</details>
<details>
  <summary><a>https://www.google.com</a>에 접속할 때 일어나는 일에 대해 설명해주세요.</summary><br>

  먼저 브라우저가 URL을 파싱해서 프로토콜과 도메인을 파악합니다.<br>

  이후 DNS 조회 과정이 일어나는데, `www.google.com`이라는 도메인 이름을 실제 IP 주소로 변환하기 위해 브라우저 캐시부터 시작해서 시스템 캐시, 로컬 DNS 서버를 거쳐서 최종적으로 IP 주소를 찾아냅니다.<br>

  IP 주소를 알아내면 3-way handshake 과정을 통해 해당 서버의 443번 포트와 TCP 연결을 설정하며, 추가로 HTTPS이기 때문에 보안 연결을 위한 TLS handshake를 진행하는데, 이때 암호화 방식을 협상하고 서버 인증서를 확인해서 보안 연결을 설정합니다.<br>

  보안 연결이 완료되면 HTTP 요청 메시지가 서버에 전송되며, 서버는 이에 대한 HTTP 응답 메시지를 내려줍니다.<br>

  서버로부터 전달된 HTTP 응답 메시지는 브라우저에서 받아서 최종적으로 화면에 렌더링 합니다.
</details>
<details>
  <summary>HTTP 메서드의 종류와 이것이 하는 역할에 대해 설명해주세요.</summary><br>

  HTTP 메서드는 <b>클라이언트가 서버에게 어떤 동작을 요청할지를 나타내는 방법</b>입니다.<br>

  <b>GET</b>은 서버로부터 리소스를 조회할 때 사용하며, 데이터를 가져오기만 하고 서버의 상태를 변경하지는 않습니다.<br>

  <b>POST</b>는 서버에 새로운 리소스를 생성할 때 주로 사용합니다.<br>

  <b>PUT</b>은 서버에 존재하는 리소스를 수정하거나 존재하지 않으면 생성합니다. 특정 리소스에 대한 전체 데이터를 새로운 내용으로 교체할 때 사용합니다.<br>

  <b>PATCH</b>는 특정 리소스의 일부분만을 수정할 때 사용합니다. PUT과 달리 전체가 아닌 특정 필드만 업데이트 하는 경우에 사용합니다.<br>

  <b>DELETE</b>는 서버의 리소스를 삭제할 때 사용합니다.<br>

  <b>HEAD</b>는 GET과 비슷하지만 응답 바디 없이 헤더 정보만 가져올 때 사용합니다.<br>

  <b>OPTIONS</b>는 서버가 특정 리소스에 대해 어떤 메서드들을 지원하는지 확인할 때 사용합니다.
</details>
<details>
  <summary>GET과 POST의 차이에 대해 설명해주세요.</summary><br>

  GET은 URL에 데이터가 노출되지만 POST는 요청 바디에 숨겨져서 전송된다는 차이가 있으며, 때문에 보안적인 측면에서 POST가 상대적으로 안전합니다.<br>
  
  또한 GET 요청에 대한 응답은 브라우저에 자동으로 캐싱되어, 같은 URL 요청 시 캐싱된 데이터를 사용할 수 있지만, POST 요청은 보통 서버의 상태를 변경하는 작업이기 때문에 브라우저가 기본적으로 캐싱하지 않아서 같은 URL 요청도 매번 새로운 요청을 보낸다는 차이가 있습니다.
</details>
<details>
  <summary>HTTP 상태 코드에 대해 설명해주세요.</summary><br>

  HTTP 상태 코드는 <b>클라이언트의 요청에 대한 서버의 응답 상태를 나타내는 3자리 숫자 코드</b>이며, 첫 번째 자리 숫자에 따라 5개의 그룹으로 나뉩니다.<br>

  <b>100번대</b>는 <b>정보성 응답</b>으로, 요청이 수신되어 처리 중임을 나타냅니다.<br>

  <b>200번대</b>는 <b>성공 응답</b>으로, 요청이 성공적으로 처리되었음을 의미합니다.<br>

  <b>300번대</b>는 <b>리다이렉션 응답</b>으로, 클라이언트가 요청한 리소스가 이동된 경우 이를 알리기 위한 코드입니다.<br>

  <b>400번대</b>는 <b>클라이언트 오류에 대한 응답</b>으로, 클라이언트 측의 잘못된 요청으로 인해 오류가 발생했음을 의미합니다.<br>

  <b>500번대</b>는 <b>서버 오류에 대한 응답</b>으로, 명백히 올바른 요청에 대해 서버 내부에서 오류가 발생했음을 의미합니다.
</details>

#### 자료구조/알고리즘
<details>
  <summary>스택과 큐에 대해 설명해주세요.</summary><br>

  <b>스택(Stack)</b>은 LIFO(Last In First Out) 구조로, 마지막에 들어온 데이터가 가장 먼저 나가는 방식의 자료구조입니다.<br>
  주로 함수 호출 관리, 브라우저의 뒤로가기 기능, 수식의 괄호 검사, DFS 알고리즘 등에서 사용하며, 시간 복잡도는 모든 기본 연산이 O(1)입니다.<br>

  <b>큐(Queue)</b>는 FIFO(First In First Out) 구조로, 먼저 들어온 데이터가 먼저 나가는 방식의 자료구조입니다.<br>
  주로 프로세스 스케줄링, I/O 작업 대기열, BFS 알고리즘, 버퍼링 등에 사용되며, 시간 복잡도는 모든 기본 연산이 O(1)입니다.
</details>
<details>
  <summary>트리와 힙에 대해 설명해주세요.</summary><br>

  <b>트리(Tree)</b>는 계층적 구조를 가진 비선형 자료구조로, 노드들이 부모-자식 관계로 연결되어 있습니다.<br>
  최상위 루트 노드부터 시작해서 각 노드가 여러 자식 노드를 가질 수 있으며, 사이클이 존재하지 않습니다.<br>
  주로 파일 시스템, DOM 구조, 의사결정 트리 등과 같이 계층적 데이터 표현이 필요한 경우에 사용됩니다.<br>

  <b>힙(Heap)</b>은 완전 이진 트리 기반의 자료구조로, 부모와 자식 간에 특정한 순서 관계를 만족합니다.<br>
  <b>최대힙</b>은 부모 노드의 값이 자식 노드의 값보다 항상 크거나 같고, <b>최소힙</b>은 부모 노드의 값이 자식 노드의 값보다 항상 작거나 같습니다.<br>
  힙의 핵심 특징은 루트 노드가 최대힙에서는 항상 최댓값을 의미하고, 최소힙에서는 항상 최솟값을 의미한다는 점이며, 이러한 특징 때문에 주로 최댓값/최솟값을 빠르게 찾아야 하는 상황에서 유용하게 사용됩니다.<br>
  힙은 새로운 노드의 삽입과 삭제 시 힙의 속성을 유지하기 위해 heapify 과정을 거치며, 이때의 시간 복잡도는 O(log n)입니다.

  > <b>완전 이진 트리(Complete Binary Tree)</b><br>
  > 완전 이진 트리는 다음 두 가지 조건을 충족하는 트리를 의미합니다.<br>
  > 첫째, 마지막 레벨을 제외하고 모든 노드가 채워져 있어야 합니다. 마지막 레벨의 노드는 다 채워져 있을 수도 있고 아닐 수도 있습니다.<br>
  > 둘째, 노드는 왼쪽에서 오른쪽 방향으로 채워져야 합니다.
</details>
<details>
  <summary>배열과 연결 리스트의 차이에 대해 설명해주세요.</summary><br>

  <b>배열(Array)</b>은 메모리상에서 연속적인 공간에 동일한 타입의 데이터를 저장하는 자료구조입니다.<br>
  인덱스를 통해 직접 접근이 가능하여 임의 접근(Random Access)이 O(1) 시간에 이루어집니다.<br>
  장점으로는 빠른 접근 속도와 메모리 효율성이 있고, 단점으로는 크기가 고정되어 있어 동적 할당이 어렵고, 중간 삽입/삭제 시 O(n)의 시간이 소요됩니다.<br>

  <b>연결 리스트(Linked List)</b>는 노드들이 포인터로 연결된 자료구조입니다.<br>
  각 노드는 데이터와 다음 노드를 가리키는 포인터를 가지고 있어, 메모리상에서 연속적이지 않은 위치에 저장될 수 있습니다.<br>
  장점은 동적으로 크기 조절이 가능하고, 삽입/삭제가 O(1) 시간에 가능하다는 점이며, 단점으로는 순차 접근(Sequential Access)만 가능하여 특정 위치에 접근하려면 O(n) 시간이 걸리고, 포인터를 위한 추가적인 메모리가 필요하다는 점이 있습니다.<br>
  
  핵심 차이점은 <b>메모리 구조(연속 vs 비연속)</b>, <b>접근 방식(임의 vs 순차)</b>, <b>크기 변경 가능성</b>, 그리고 <b>삽입/삭제와 접근의 시간복잡도 트레이드오프</b>입니다.<br>
  빈번한 접근이 필요하면 배열을, 빈번한 삽입/삭제가 필요하면 연결 리스트를 선택하는 것이 일반적입니다.
</details>
<details>
  <summary>해시 테이블에 대해 설명해주세요.</summary><br>

  <b>해시 테이블(Hash Table)</b>은 <b>키-값(Key-Value) 쌍으로 데이터를 저장하는 자료구조</b>로, <b>해시 함수</b>를 사용해서 키를 버킷(Bucket)의 인덱스(Index)로 변환하여 데이터에 빠르게 접근할 수 있도록 합니다.<br>

  이상적인 경우 삽입, 삭제, 검색 모두 O(1)의 시간이 소요됩니다. 하지만 <b>해시 충돌</b>이 많이 발생하면 최악의 경우 O(n)까지 늘어날 수 있습니다.<br>

  해시 충돌은 서로 다른 키가 같은 해시값을 가지는 경우에 발생하며, 이를 해결하기 위해서는 같은 인덱스에 연결 리스트로 여러 값을 저장하는 <b>체이닝 방식</b>을 사용하거나, 다른 빈 공간을 찾아서 저장하는 <b>개방 주소법</b>을 사용하여 해결할 수 있습니다.<br>

  해시 테이블은 데이터베이스 인덱싱, 프로그래밍 언어의 Dictionary나 Map 자료형 등에 사용됩니다.
</details>
<details>
  <summary>우선순위 큐에 대해 설명해주세요.</summary><br>

  <b>우선순위 큐(Priority Queue)</b>는 각 원소에 우선순위가 있어서, <b>들어온 순서와 관계없이 우선순위가 높은 원소가 먼저 처리되는 자료구조</b>입니다.<br>
  즉, 우선순위가 가장 높은 데이터를 먼저 꺼내기 위해 고안된 자료구조로, 이를 구현하기 위해서는 일반적으로 <b>힙(Heap)</b>을 사용합니다.<br>

  힙은 <b>완전 이진 트리</b>를 기반으로 구현되었기 때문에 우선순위 큐를 힙으로 구현하면 삽입과 삭제가 모두 <b>O(log n)</b> 시간에 처리할 수 있습니다.<br>
  배열이나 연결 리스트로도 구현 가능하지만 이 둘은 선형 자료구조이며, 삽입 또는 삭제 연산을 위한 시간 복잡도가 O(n)이므로, 비효율적입니다.<br>

  우선순위 큐는 운영체제의 프로세스 스케줄링, 최단 경로 알고리즘 등에서 주로 사용됩니다.
</details>
<details>
  <summary>이진 탐색 트리에 대해 설명해주세요.</summary><br>

  <b>이진 탐색 트리(Binary Search Tree)</b>는 이진 트리 구조에서 <b>특별한 규칙</b>이 추가된 자료구조입니다.<br>

  이진 탐색 트리에서 <b>각 노드의 왼쪽 자식은 현재 노드보다 작은 값, 오른쪽 자식은 현재 노드보다 큰 값</b>을 가지며, 이 규칙은 모든 노드에 적용됩니다.<br>

  시간 복잡도는 균형 잡힌 트리에서는 O(log n)이지만, 노드가 한쪽으로 치우친 형태이면 최악의 경우 O(n)까지 늘어날 수 있습니다.
</details>
<details>
  <summary>RB 트리에 대해 설명해주세요.</summary><br>

  <b>RB(Red-Black)</b> 트리는 <b>자가 균형 이진 탐색 트리</b>의 한 종류로, BST의 문제점인 <b>편향된 트리</b>를 해결하기 위해 각 노드에 색깔(빨간색 또는 검은색)을 부여하고, “루트 노드와 리프 노드는 항상 검은색이어야 한다”, “빨간색 노드의 자식은 반드시 검은색이어야 한다”와 같은 특별한 규칙들을 적용한 자료구조입니다.<br>

  RB 트리는 이러한 규칙을 깨지 않기 위해 삽입이나 삭제 시에 색깔 변경이나 회전 연산을 통해 다시 균형을 맞추며, 트리의 높이가 항상 균형되도록 유지합니다.
</details>
<details>
  <summary>Big-O 표기법의 시간 복잡도 크기 순서를 말해주세요.</summary><br>

  O(1) < O(log N) < O(N) < O(N log N) < O(N^2) < O(2^N) < O(N!)
</details>
<details>
  <summary>주요 정렬 방식에 대해 설명해주세요.</summary><br>

  <b>버블 정렬</b>은 첫 번째 요소부터 마지막 요소까지 순회하며, 서로 인접한 두 원소를 비교해가며 정렬하는 알고리즘으로, 가장 간단하지만 <b>O(n²)</b>의 시간복잡도로 비효율적입니다. 따라서 실제로는 거의 사용하지 않습니다.

  <b>선택 정렬</b>은 매번 최솟값을 찾아서 앞쪽에 배치하는 방식으로, 역시 <b>O(n²)</b>의 시간복잡도를 갖지만 교환 횟수가 적어 메모리 쓰기가 비싼 환경에서는 고려해볼 수 있는 정렬 방식입니다.
  
  <b>삽입 정렬</b>은 두 번째 요소부터 시작해서 그 앞에 존재하는 원소들과 비교하여 올바른 위치를 찾아 삽입하는 정렬 알고리즘입니다. 최악의 경우 <b>O(n²)</b>의 시간복잡도를 갖지만 거의 정렬된 데이터에 대해서는 <b>O(n)</b>에 가까워서 효율적입니다.
  
  <b>병합 정렬</b>은 주어진 배열을 크기가 1이 될 때까지 나누고 각각을 정렬한 후 합치는 <b>분할 정복 방식</b>에 기반한 정렬 알고리즘입니다. 항상 <b>O(n log n)</b>의 시간복잡도를 보장하고 안정 정렬이라는 장점이 있으나 추가 메모리가 필요하다는 단점이 있습니다.
  
  <b>퀵 정렬</b>은 피벗(Pivot)을 설정하고 피벗을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 분할하는 <b>분할 정복 방식</b>에 기반한 정렬 알고리즘입니다. 병합 정렬과 달리 리스트를 비균등하게 분할하며, 평균적으로 <b>O(n log n)</b>의 시간복잡도를 가지고, 제자리 정렬이 가능해서 널리 사용됩니다. 다만 최악의 경우 시간복잡도는 <b>O(n²)</b>이 될 수 있습니다.
  
  <b>힙 정렬</b>은 힙 자료구조를 이용한 정렬로, 주어진 데이터를 힙 자료구조로 만들어 최댓값 또는 최솟값부터 하나씩 꺼내서 정렬하는 알고리즘입니다. 항상 <b>O(n log n)</b>을 보장하고 제자리 정렬이 가능합니다. 하지만 불안정 정렬이고 실제로는 퀵 정렬보다 느린 경우가 많습니다.
</details>
<details>
  <summary>DFS와 BFS에 대해 설명해주세요.</summary><br>

  DFS와 BFS는 그래프나 트리를 탐색하는 두 가지 기본적인 알고리즘입니다.

  <b>DFS(Depth First Search)</b>는 한 방향으로 계속 깊게 들어가다가 더 이상 갈 곳이 없으면 뒤로 돌아와서 다른 경로를 탐색하는 방식입니다.<br>
  구현은 보통 재귀나 스택을 사용하며, 현재 노드를 방문 처리하고, 인접한 노드들을 하나씩 재귀 호출하는 식으로 구현합니다.<br>
  DFS는 메모리를 적게 사용하지만 최단 경로를 보장하지 않습니다.<br>
  
  <b>BFS(Breadth Fisrt Search)</b>는 현재 레벨의 모든 노드를 먼저 방문하고, 그 다음 레벨로 넘어가는 방식입니다.<br>
  이는 큐를 사용해서 구현하는데, 시작 노드를 큐에 넣고, 큐에서 하나씩 빼면서 그 노드의 인접 노드들을 다시 큐에 넣는 과정을 반복하는 식으로 구현합니다.<br>
  BFS는 DFS에 비해 메모리를 더 많이 사용하지만 최단 경로를 찾을 수 있습니다.<br>
  
  시간 복잡도는 둘 다 O(V + E)로 동일합니다.
</details>

---

### 🧑‍💻 Programming Language
#### 공통
<details>
  <summary>객체지향 프로그래밍에 대해 설명해주세요.</summary><br>

  객체지향 프로그래밍은 <b>현실 세계의 사물들을 객체로 모델링해서 프로그램을 설계하고 구현하는 프로그래밍 패러다임</b>입니다.<br>

  기존의 절차지향 프로그래밍이 함수 중심으로 프로그램을 작성했다면, 객체지향은 관련된 속성과 기능을 캡슐화하는 <b>객체</b>를 중심으로 프로그램을 작성합니다.<br>

  객체지향은 코드의 재사용성이 높아지고, 유지보수가 쉬워지며, 현실 세계를 모델링하기 때문에 이해하기 쉽다는 장점이 있으나, 절차지향 프로그래밍에 비해 코드의 복잡성이 증가하고, 실행 속도가 느립니다.
</details>
<details>
  <summary>객체지향 프로그래밍의 4가지 특징에 대해 설명해주세요.</summary><br>

  <b>캡슐화(Encapsulation)</b>란 데이터와 그 데이터를 조작하는 메서드를 하나의 클래스로 묶고, 외부에서 직접 접근하지 못하도록 정보를 은닉하는 것입니다. 이를 통해 데이터의 무결성을 보장하고 외부 의존성을 줄일 수 있습니다.<br>

  <b>상속(Inheritance)</b>이란 기존 클래스의 속성과 메서드를 새로운 클래스가 물려받아 재사용하는 것입니다. 이를 통해 코드의 재사용성을 높이고 계층적 분류가 가능해집니다.<br>

  <b>다형성(Polymorphism)</b>이란 동일한 인터페이스나 부모 클래스 타입으로 서로 다른 객체들을 참조할 수 있고, 각 객체의 실제 타입에 따라 다른 동작을 수행하는 것입니다. 이를 통해 유연하고 확장 가능한 코드를 작성할 수 있습니다.<br>

  <b>추상화(Abstraction)</b>란 복잡한 구현 세부사항을 숨기고 중요한 특징만을 인터페이스나 추상 클래스로 제공하는 것입니다.
</details>
<details>
  <summary>객체지향 프로그래밍의 5대 원칙에 대해 설명해주세요.</summary><br>

  <b>단일 책임 원칙(SRP, Single Responsibility Principle)</b>이란 <b>하나의 클래스는 하나의 책임만 가져야 한다는 원칙</b>입니다. 즉, 하나의 클래스에 모든 기능을 부여하지 말고 목적과 취지에 맞게 속성과 메서드를 구성함으로써 하나의 책임만을 갖도록 해야함을 의미합니다.<br>

  <b>개방-폐쇄 원칙(OCP, Open-Closed Principle)</b>이란 <b>확장에는 열려있고 수정에는 닫혀있어야 한다는 원칙</b>입니다. 즉, 기존 코드를 변경하지 않고도 새로운 기능을 추가할 수 있어야 합니다. 이는 인터페이스나 추상 클래스를 활용해서 새로운 구현체를 추가하는 방식으로 달성할 수 있습니다.<br>
  
  <b>리스코프 치환 원칙(LSP, Liskov Substitution Principle)</b>이란 <b>상위 타입의 객체를 하위 타입의 객체로 치환해도 프로그램이 정상적으로 동작해야 한다는 원칙</b>입니다. 이는 인터페이스와 구현체 간의 관계, 부모 클래스와 자식 클래스 간의 관계를 얼마나 논리적으로 설계했느냐에 대한 원칙으로, 하위 클래스가 상위 클래스의 역할을 대신할 때 이것이 논리적으로 맞아 떨어져야 함을 의미합니다.</b>
  
  <b>인터페이스 분리 원칙(ISP, Interface Segregation Principle)</b>이란 <b>클라이언트는 자신이 사용하지 않는 메서드에 의존하면 안 된다는 원칙</b>입니다. 즉, 하나의 큰 인터페이스보다는 여러 개의 구체적인 인터페이스로 나누어서 상황에 맞는 메서드만 제공할 수 있도록 해야함을 의미합니다.<br>
  
  <b>의존성 역전 원칙(DIP, Dependency Inversion Principle)</b>이란 <b>고수준 모듈이 저수준 모듈에 의존하는 경우가 생기면 안 된다는 원칙</b>으로, 구체적인 구현체가 아니라 그 구현체가 구현하는 인터페이스나 추상 클래스에 의존하도록 설계함으로써 결합도를 낮추고 유연성을 높여야 함을 의미합니다.
</details>
<details>
  <summary>컴파일러와 인터프리터의 차이에 대해 설명해주세요.</summary><br>

  <b>컴파일러</b>는 소스 코드 전체를 <b>실행 전에 미리 기계어로 번역하는 방식</b>으로, 먼저 컴파일 과정을 거쳐 실행 파일을 만들고, 그 실행 파일을 직접 실행하는 방식입니다. C, C++ 같은 언어가 대표적입니다.<br>

  <b>인터프리터</b>는 소스 코드를 <b>실행 시점에 한 줄씩 읽어가며 즉시 해석하고 실행하는 방식</b>입니다. Python, JavaScript 같은 언어가 이 방식을 사용합니다.<br>

  <b>실행 속도</b> 면에서는 실행할 때마다 번역 과정을 거쳐야 하는 인터프리터 방식에 비해 이미 기계어로 변환되어 있어 CPU가 바로 실행할 수 있는 컴파일러가 훨씬 빠릅니다.<br>
  <b>개발 편의성</b> 면에서는 매번 컴파일 과정을 거쳐야하는 컴파일러에 비해 코드를 수정하면 바로 실행해볼 수 있는 인터프리터가 디버깅이나 테스트 하기가 편합니다.<br>
  또 컴파일러는 문법 오류를 컴파일 시점에 모두 잡아내지만, 인터프리터는 실행 중에 오류가 있는 줄에 도달해야 오류를 발견할 수 있다는 차이가 있습니다.
</details>
<details>
  <summary>프레임워크와 라이브러리의 차이에 대해 설명해주세요.</summary><br>

  프레임워크와 라이브러리의 가장 큰 차이점은 <b>제어의 주도권</b>이 어디에 있느냐입니다.<br>

  <b>라이브러리</b>는 개발자가 필요한 기능을 가져다 쓰기 위한 도구의 모음으로, 개발자가 언제, 어떻게 사용할지를 결정하고 직접 호출해서 사용합니다.<br>
  
  <b>프레임워크</b>는 개발자에게 전체적인 구조와 흐름을 제공하고, 개발자는 그 틀 안에서 구체적인 기능을 구현하는 방식으로, 프레임워크가 언제 개발자의 코드를 호출할지를 결정합니다.<br>
  
  즉, 라이브러리는 제어의 주도권이 <b>개발자</b>에게 있고, 프레임워크는 제어의 주도권이 <b>프레임워크</b>에게 있다는 차이가 있으며, 이러한 특성을 <b>IoC(Inversion of Control, 제어의 역전)</b>라고 부릅니다.
</details>
<details>
  <summary>Call By Value와 Call By Reference의 차이에 대해 설명해주세요.</summary><br>

  <b>Call By Value(값에 의한 호출)</b>는 <b>메서드를 호출할 때 실제 값의 복사본을 전달하는 방식</b>입니다. 원본 변수의 값을 복사해서 매개변수에 전달하기 때문에, 메서드 내에서 매개변수 값을 변경해도 원본 변수에는 영향을 주지 않습니다.<br>

  <b>Call By Reference(참조에 의한 호출)</b>는 <b>메서드를 호출할 때 변수의 메모리 주소를 직접 전달하는 방식</b>입니다. 원본 변수의 주소를 전달하기 때문에, 메서드 내에서 매개변수를 통해 값을 변경하면 원본 변수의 값도 함께 변경됩니다.
</details>
<details>
  <summary>TDD에 대해 설명해주세요.</summary><br>

  TDD(Test Driven Development)란 일반적인 개발 방식과는 다르게 <b>테스트를 먼저 작성하고 그 테스트를 통과하는 코드를 나중에 구현하는 개발 방법론</b>입니다.<br>

  TDD는 <b>Red-Green-Refactor</b>라는 3단계 사이클로 진행됩니다.
  - <b>Red 단계</b>에서는 개발할 기능 또는 모듈에 대한 테스트 케이스를 작성합니다. 아직 구현되지 않은 기능에 대한 테스트이기 때문에 당연히 실패합니다.
  - <b>Green 단계</b>에서는 테스트를 통과시키기 위한 최소한의 코드를 작성합니다. 완벽한 코드가 아니라 일단 테스트만 통과하면 됩니다.
  - <b>Refactor 단계</b>에서는 테스트가 통과하는 상태를 유지하면서 중복 제거, 구조 개선 등을 통해 Green 단계에서 작성했던 코드를 개선합니다.
  
  TDD의 장점은 버그를 조기에 발견할 수 있고, 안정성을 향상시킬 수 있으며, 테스트를 먼저 작성하다 보니 자연스럽게 요구사항을 명확히 하게 되고, 설계에 대해 더 깊이 생각하게 됩니다. 하지만 초기 개발 속도가 느려질 수 있고, 테스트 코드 자체도 유지보수 범위에 포함된다는 단점이 있습니다.
</details>
<details>
  <summary>DDD에 대해 설명해주세요.</summary><br>

  DDD(Domain Driven Design)란 <b>도메인을 중심으로 프로그램을 설계하는 개발 방법론</b>입니다. 즉, 기술적인 구현보다는 <b>비즈니스 도메인을 먼저 정확히 이해하고 그것을 코드로 표현하는 데 집중</b>하자는 것입니다.<br>

  여기서 <b>도메인</b>이라는 것은 소프트웨어가 해결하려는 문제 영역, 즉 <b>비즈니스 영역</b>을 말합니다. 예를 들어 쇼핑몰이라면 주문, 결제, 배송 같은 것들이 도메인이 되는 거죠.<br>
  
  DDD의 장점은 유비쿼터스 언어, 바운디드 컨텍스트와 같은 개념을 사용함으로써 비즈니스 요구사항 변화에 유연하게 대응할 수 있고, 도메인 전문가와 개발자 간의 소통이 원활해진다는 점입니다.<br>
  
  단, 학습 곡선이 높고, 작은 프로젝트에 적용하기에는 오버엔지니어링이 될 수 있어서 복잡한 비즈니스 도메인을 가진 대규모 프로젝트에서 주로 사용됩니다.

  > <b>유비쿼터스 언어</b><br>
  > 유비쿼터스 언어란 특정 도메인에서 특정 용어가 해당 도메인에서의 의도를 명확히 반영하고, 도메인의 핵심 개념을 잘 전달할 수 있는 언어를 말합니다.<br>
  > 즉, <b>모든 팀원이 특정 용어를 들었을 때 같은 것을 생각할 수 있도록 명확하게 정의된 언어</b>로, 이를 통해 코드의 가독성을 높이고 코드를 분석하고 이해하는 시간을 절약할 수 있습니다.<br>

  > <b> 바운디드 컨텍스트</b><br>
  > 바운디드 컨텍스트(Bounded Context)란 <b>특정 도메인 모델에 대한 유비쿼터스 언어가 동일한 의미를 갖는 명시적인 경계</b>를 의미합니다.<br>
  > 이는 복잡한 시스템을 여러 개의 독립적이고 관리 가능한 부분으로 나누는 방법으로, 각 컨텍스트 내에서만 유효한 용어와 개념을 정의하여 모호성을 줄이고 일관된 모델을 유지하는 방법입니다.<br>
  > 예를 들어, '고객'이라는 도메인은 결제 도메인 입장에서는 신용카드 정보나 계좌 정보 등을 가진 '결제자'를 의미하고, 배송 도메인 입장에서는 상품을 받을 주소와 우편번호, 전화번호 등을 가진 '수취자'를 의미하기 때문에, 각 도메인마다 별도의 바운디드 컨텍스트를 두고 해당 컨텍스트에 맞는 모델을 정의해야 합니다.
</details>
<details>
  <summary>VO와 DTO, BO, DAO에 대해 설명해주세요.</summary><br>

  <b>VO(Value Object)</b>는 값 자체를 표현하는 객체입니다. 한 번 생성되면 변경할 수 없는 불변 객체이고, 값이 같으면 같은 객체로 취급됩니다. 주로 도메인 모델에서 특정 값을 나타낼 때 사용합니다.<br>

  <b>DTO(Data Transfer Object)</b>는 계층 간 데이터 전송을 위한 객체입니다. 주로 컨트롤러와 서비스 계층 사이, 또는 API 응답에서 사용됩니다. 비즈니스 로직은 없고 데이터를 담아서 전달하는 역할만 합니다.<br>
  
  <b>BO(Business Object)</b>는 비즈니스 로직을 포함하는 객체입니다. 실제 업무 규칙과 처리 로직이 들어있어서 도메인의 핵심 기능을 담당합니다.<br>
  
  <b>DAO(Data Access Object)</b>는 데이터베이스 접근을 담당하는 객체입니다. CRUD 연산을 수행하는 메소드들을 가지고 있고, 비즈니스 로직과 데이터 접근 로직을 분리하는 역할을 합니다.
</details>

#### Java
<details>
  <summary>Java의 특징에 대해 설명해주세요.</summary><br>

  자바는 JVM만 설치되어 있다면 자바 컴파일러가 컴파일 한 바이트코드를 JVM에서 각 플랫폼(운영체제)에 맞게 이를 해석하여 실행하기 때문에 어떤 운영체제건 동일하게 실행된다는 <b>플랫폼 독립성</b>의 특징을 갖고 있습니다.<br>

  또한 <b>객체지향 프로그래밍</b>을 완전히 지원하여 캡슐화, 상속, 다형성, 추상화를 모두 구현할 수 있어 코드의 재사용성과 유지보수성이 뛰어납니다.<br>

  또 <b>가비지 컬렉터</b>를 통해 자동으로 메모리 관리를 해주어 개발자가 메모리 관리에 들이는 비용이 적으며, <b>강한 타입 체크</b>를 통해 컴파일 타임에 대부분의 오류를 잡아낼 수 있습니다.
</details>
<details>
  <summary>Java는 컴파일러와 인터프리터 방식 중 어떤 방식을 사용하나요?</summary><br>

  Java는 <b>컴파일러와 인터프리터 방식을 혼합해서 사용</b>합니다.<br>

  자바 코드가 실행되는 과정을 살펴보면 다음과 같습니다.
  - 먼저 자바 소스 코드가 <b>컴파일러</b>에 의해 바이트 코드로 컴파일 되며, 이 과정에서 문법 오류나 타입 체크 등의 정적 검사가 이루어집니다.
  - 이후 JVM의 클래스 로더에서 컴파일 된 바이트 코드를 JVM 메모리에 적재한 후 실행 엔진에서 이를 해석하고 실행하는데, 이때 기본적으로 <b>인터프리터</b> 방식을 사용하여 바이트코드를 한 줄씩 읽어서 해석하고 실행하게 됩니다.
  - 단, 이때 성능 최적화를 위해 <b>JIT 컴파일러</b> 방식을 사용하여, 자주 실행되는 바이트 코드의 경우에는 해석한 네이티브 코드를 캐시해두었다가 이후에 다시 실행해야 할 때에는 해석하는 과정을 생략하고 캐싱되어 있는 네이티브 코드를 바로 실행하는 방식을 사용하기도 합니다.
</details>
<details>
  <summary>Java의 접근 제어자 종류와 특징에 대해 설명해주세요.</summary><br>

  <b>public</b>은 가장 개방적인 접근 제어자로, <b>어디서든 접근이 가능</b>합니다. 주로 외부에 공개해야 하는 API나 메서드에 사용합니다.<br>

  <b>protected</b>는 <b>같은 패키지 내의 클래스</b> 또는 <b>다른 패키지더라도 상속 관계에 있는 자식 클래스</b>에서만 접근할 수 있습니다. 이는 상속을 통한 확장을 염두에 둔 멤버들에 주로 사용합니다.<br>
  
  <b>default(package-private)</b>는 접근 제어자를 명시하지 않으면 적용되는 기본값으로, <b>같은 패키지 내에서만 접근</b>이 가능합니다. 따라서 이는 패키지 단위로 모듈화할 때 유용합니다.<br>
  
  <b>private</b>은 가장 제한적인 접근 제어자로, <b>같은 클래스 내에서만 접근</b>할 수 있습니다. 따라서 외부에 노출되어서는 안 되는 내부 구현 세부사항을 숨기는 데 사용합니다.
</details>
<details>
  <summary>Java의 원시 타입들은 무엇이 있으며 각각 몇 바이트를 차지하나요?</summary><br>

  먼저 정수형 타입으로는 1byte 크기의 <b>byte</b>, 2byte 크기의 <b>short</b>, 4byte 크기의 <b>int</b>, 8byte 크기의 <b>long</b>이 있습니다.<br>

  실수형 타입으로는 4byte 크기의 <b>float</b>, 8byte 크기의 <b>double</b>이 있으며, 문자형 타입으로는 2byte 크기의 <b>char</b>가 있고, 논리형 타입으로는 1byte 크기의 <b>boolean</b>이 있습니다.

  > <b>char가 2byte인 이유</b><br>
  > 이는 유니코드를 지원하기 위해서입니다. 1byte로는 영어 알파벳과 기본 기호만 표현할 수 있기 때문에 한국어, 중국어, 일본어 등 다국어 지원이 불가능합니다. 따라서 char는 유니코드에 포함되어 있는 모든 문자를 표현할 수 있도록 2byte로 설계되었습니다.
</details>
<details>
  <summary>Java는 Call By Value와 Call By Reference 방식 중 어떤 것을 사용하나요?</summary><br>

  <b>자바는 항상 Call By Value 방식만 사용</b>합니다. 하지만 여기서 주의할 점이 있습니다.<br>

  원시 타입(int, double, boolean 등)의 경우 값 자체가 복사되어 전달되므로 전형적인 Call By Value입니다. 따라서 메서드 내에서 값을 변경해도 원본에 영향을 주지 않습니다.<br>
  
  다만 참조 타입(객체, 배열 등)의 경우에는 <b>참조값(주소값)이 복사되어 전달</b>됩니다. 즉, 참조값 자체는 복사본이지만, 그 참조값이 가리키는 객체는 동일하기 때문에 객체의 내부 상태를 변경하면 원본 객체에 영향을 줍니다.<br>
  
  정리하면, 자바는 순수한 Call By Value 언어이지만, 참조 타입의 경우 참조값이 복사되어 전달되면서 마치 Call By Reference처럼 보이는 효과가 나타날 뿐입니다.
</details>
<details>
  <summary>Java의 static에 대해 설명해주세요.</summary><br>

  `static`은 <b>클래스 레벨에 속한다는 의미</b>입니다. 객체를 생성하지 않고도 클래스 이름으로 직접 접근할 수 있으며, 모든 인스턴스가 공유하는 특성을 가집니다.<br>

  `static` 멤버들은 JVM 메모리의 <b>메서드 영역(Method Area)</b>에 저장됩니다. 따라서 클래스가 처음 로딩될 때 한 번만 메모리에 할당되고, 프로그램이 종료될 때까지 유지됩니다.
</details>
<details>
  <summary>String, StringBuffer, StringBuilder의 차이에 대해 설명해주세요.</summary><br>

  `String`은 <b>불변(immutable) 객체</b>입니다. 한 번 생성하면 내용을 변경할 수 없고, 문자열 연산을 할 때마다 새로운 `String` 객체가 생성됩니다. 즉, 기존 객체를 수정하는 것이 아니라 새로운 `String` 객체를 만들어 참조만 바꿉니다.<br>

  `StringBuffer`와 `StringBuilder`는 둘 다 <b>가변(mutable) 객체</b>입니다. 내부 버퍼를 가지고 있어서 문자열을 수정할 때 새로운 객체를 생성하지 않고 기존 버퍼의 내용을 변경합니다. 이 둘의 가장 핵심적인 차이점은 <b>동기화 지원 여부</b>입니다.<br>
  - `StringBuffer`는 <b>thread-safe</b>합니다. 모든 메서드가 `synchronized`로 동기화 처리되어 있어서 멀티스레드 환경에서 안전하게 사용할 수 있습니다. 하지만 동기화 오버헤드로 인해 성능이 상대적으로 낮습니다.<br>
  - `StringBuilder`는 <b>thread-unsafe</b>합니다. 동기화 처리가 되어 있지 않아서 멀티스레드 환경에서 안정성이 낮지만, 그만큼 성능은 높습니다.
  
  따라서 싱글스레드 환경에서 문자열 조작이 많다면 `StringBuilder`를, 멀티스레드 환경에서 문자열 조작이 필요하다면 `StringBuffer`를, 단순한 문자열 저장이나 적은 연산이라면 `String`을 사용하면 됩니다.

  > <b>Thread-safe</b><br>
  > Thread-safe란 멀티 스레드 환경에서 여러 스레드가 동시에 같은 코드나 객체에 접근해도 안전하게 동작하는 것을 의미합니다. 즉, 동기화 메커니즘을 통해 한 번에 하나의 스레드만 임계 영역에 접근할 수 있도록 보장함으로써 데이터 손상을 방지하는 것입니다.

  > <b>왜 동기화(synchronized)가 걸려있으면 속도가 느린걸까?</b><br>
  > 동기화 처리가 되어있는 영역에 진입하기 위해서는 스레드가 락을 획득하고 해제하는 과정이 필요하며, 이러한 부가적인 작업들로 인해 속도가 느려집니다. 또한 특정 스레드가 락을 잡고 있으면, 다른 스레드들은 그 락이 해제될 때까지 대기해야 합니다. 특히 락을 오래 잡고 있는 작업이 있으면, 다른 스레드들이 모두 대기 상태에 빠져서 전체적인 처리량이 크게 떨어집니다. 또한 스레드가 블로킹되고 다시 스케줄링되는 과정에서 CPU의 컨텍스트 스위칭이 발생하는데, 짧은 시간 동안 락을 자주 획득하고 해제하는 상황에서는 컨텍스트 스위칭에 따른 오버헤드로 인해 성능이 떨어질 수 있습니다.

  > <b>싱글 스레드로 접근한다는 가정하에선 StringBuilder와 StringBuffer의 성능이 똑같을까?</b><br>
  > `StringBuffer`의 경우 모든 메서드가 `synchronized`로 동기화되어 있기 때문에 싱글 스레드 환경에서도 메서드 호출 시마다 매번 락을 획득하고 해제하는 과정을 수행합니다. 즉, `StringBuffer`는 여전히 메서드 호출에 부가적인 비용이 들며, 따라서 완전히 동기화가 없는 `StringBuilder`에 비해 느립니다.
</details>
<details>
  <summary>불변 객체란 무엇인지 설명해주세요.</summary><br>

  불변 객체는 <b>한 번 생성된 후에 그 상태를 변경할 수 없는 객체</b>를 말합니다. 객체가 생성된 시점 이후로는 내부 데이터를 수정할 수 없어서, 항상 동일한 상태를 유지합니다.<br>

  이러한 불변 객체의 장점으로는 <b>스레드 안전성</b>이 있습니다. 상태가 변하지 않으니까 여러 스레드에서 동시에 접근해도 문제가 없습니다. 또한 객체의 `hashCode`가 변하지 않아서 `HashMap` 같은 곳에서 Key로 사용하기에 안전합니다.<br>
  
  단, 불변 객체를 수정하고자 할 경우에는 항상 새로운 객체를 생성해야 하기 때문에 이에따른 <b>메모리 누수</b>와 <b>성능 저하</b>가 발생할 수 있습니다.
</details>
<details>
  <summary>Java의 String이 불변객체인 이유에 대해 설명해주세요.</summary><br>

  첫 번째는 <b>메모리 효율성</b> 때문입니다. 자바는 <b>String Constrant Pool</b>이라는 특별한 메모리 영역을 사용해서 동일한 문자열 리터럴을 하나의 객체로 공유합니다. 예를 들어 특정 문자열이 여러 곳에서 사용되면 자바는 객체를 하나만 생성해서 참조를 공유하는 방식으로 동작하는데, 만약 `String`이 가변 객체라면 한 곳에서 값을 변경했을 때 다른 모든 곳이 영향을 받게 됩니다.<br>

  두 번째는 <b>Thread-Safety</b> 입니다. 불변 객체는 본질적으로 멀티 스레드 환경에서 안전합니다. 여러 스레드가 동시에 같은 `String`에 접근해도 내용 자체가 변경될 수 없기 때문에 별도의 동기화 처리 없이도 안전하게 사용할 수 있습니다.<br>
  
  세 번째는 <b>성능상의 이점</b>입니다. `String`은 `hashCode`를 한 번 계산하면 내부적으로 캐싱해둡니다. 내용이 바뀔 일이 없으니까 매번 다시 계산할 필요가 없어서 `HashMap` 같은 자료구조에서 Key로 사용할 때 성능이 향상됩니다.<br>
  
  이런 장점들 때문에 문자열 연산 시 새 객체를 생성해야 하는 단점이 있음에도 불구하고 자바는 `String`을 불변으로 설계하였습니다.
</details>
<details>
  <summary>Java의 컬렉션 프레임워크에 대해 설명해주세요.</summary><br>

  Java에서 컬렉션 프레임워크란 <b>다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스들의 집합</b>을 의미합니다.<br>

  즉, 데이터를 저장하는 자료구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현해놓은 것입니다.<br>

  이러한 컬렉션 프레임워크는 Java의 인터페이스를 사용하여 구현됩니다.<br>

  컬렉션 프레임워크에서는 `List`, `Set`, `Map`과 같이 데이터를 저장하는 주요 자료구조에 따라 인터페이스를 정의하고 있습니다.<br>

  이 중에서 `List`와 `Set` 인터페이스는 모두 `Collection` 인터페이스를 상속받지만, 구조상의 차이로 인해 `Map` 인터페이스는 별도로 정의됩니다.
</details>
<details>
  <summary>Java의 List, Set, Map의 차이에 대해 설명해주세요.</summary><br>

  <b>List</b>는 <b>순서가 있고 중복을 허용하는 컬렉션</b>입니다. 인덱스로 요소에 접근할 수 있고, 같은 값을 여러 번 저장할 수 있습니다.<br>

  <b>Set</b>은 <b>순서가 없고 중복을 허용하지 않는 컬렉션</b>입니다. 수학의 집합 개념과 같아서 동일한 요소는 하나만 존재할 수 있습니다.<br>
  
  <b>Map</b>은 <b>순서 없이 키와 값의 쌍으로 데이터를 저장하는 컬렉션</b>입니다. 키는 중복될 수 없지만 값은 중복 가능하며, 키를 통해 값에 접근합니다.<br>
</details>
<details>
  <summary>ArrayList는 내부적으로 어떻게 구현되어있나요?</summary><br>

  `ArrayList`는 내부적으로 `Object` 배열을 사용하여 데이터를 저장합니다. 따라서 배열의 인덱스 기반 접근 방식을 그대로 활용하기 때문에 O(1) 시간 복잡도로 get/set 연산이 가능합니다.<br>
  
  삽입, 삭제 연산도 배열과 동일하게 모든 요소들을 한 칸씩 이동시키는 작업이 필요하기 때문에 최악의 경우 O(n)의 시간복잡도가 걸립니다.<br>

  `ArrayList`는 요소를 추가할 때 배열이 가득 차면 현재 크기의 1.5배로 새로운 배열을 생성한 후 기존 데이터를 새로운 배열로 복사하는 방식으로 동작합니다.
</details>
<details>
  <summary>클래스, 객체, 인스턴스의 차이에 대해 설명해주세요.</summary><br>

  <b>클래스(Class)</b>는 객체를 만들기 위한 설계도나 틀입니다. 객체가 가져야 할 속성(필드)과 행동(메서드)을 정의해놓은 것입니다. 즉, 아직 실제로 존재하는 것이 아니라 개념적인 설계도입니다.<br>

  <b>객체(Object)</b>는 클래스를 바탕으로 실제로 생성된 실체입니다. 즉, 클래스라는 설계도를 이용해서 메모리에 실제로 만들어진 것입니다.<br>
  
  <b>인스턴스(Instance)</b>는 객체를 부르는 다른 이름입니다. 인스턴스는 영어로 “사례” 혹은 “예시”를 의미합니다. 즉, 객체를 인스턴스라고 부르는 것은 그 객체가 특정 클래스로 만든 객체의 구체적인 사례(실제 예)임을 강조할 때 사용합니다. 또한 객체가 실제로 메모리에 할당된 상태를 강조하는 의미로 인스턴스라고 부르기도 합니다.
</details>
<details>
  <summary>인터페이스와 추상 클래스의 차이에 대해 설명해주세요.</summary><br>

  <b>추상 클래스</b>는 <b>상속 관계에서 공통 기능을 제공하면서도 일부 기능은 각자 구현하도록 강제</b>함으로써, 공통된 특성을 추상화하고 상속에 대한 계층 구조를 명확히 표현하는데에 그 목적이 있습니다.<br>
  
  <b>인터페이스</b>는 <b>특정 역할이나 기능을 수행하기 위해 반드시 구현해야 할 메서드들을 명세하는 것</b>으로, 서로 다른 클래스들이 같은 인터페이스를 구현함으로써 결과적으로는 해당 인터페이스의 구현 객체들이 동일한 방식으로 사용될 수 있도록 보장하는 것에 그 목적이 있습니다.<br>

  추상 클래스와 인터페이스의 문법적인 차이는 다음과 같습니다.
  - 추상 클래스는 단일 상속만 가능하며, 인터페이스는 다중 구현이 가능합니다.
  - 추상 클래스는 모든 접근 제어자를 사용할 수 있지만, 인터페이스는 public 접근 제어자만 사용할 수 있습니다.
  - 추상 클래스는 변수와 상수를 선언할 수 있지만, 인터페이스는 상수만 선언할 수 있습니다.
</details>
<details>
  <summary>Java에서 다중 상속을 지원하지 않는 이유에 대해 설명해주세요.</summary><br>

  이는 <b>Diamond Problem</b> 때문입니다. 하나의 조상 클래스가 있고 이 조상 클래스를 상속받아 메서드를 각각 다르게 오버라이딩 하는 두 개의 부모 클래스가 있고, 이 두 부모 클래스를 상속받는 자식 클래스가 있다고 할 때, 자식 클래스에서는 어떤 부모 클래스의 메서드를 사용할지 결정할 수 없는 모호성 문제가 발생합니다.<br>

  C++에서는 다중 상속을 허용하되, 이러한 충돌 상황에 대해서는 개발자가 명시적으로 해결하도록 지원하지만, Java는 이러한 기능 자체를 원천 차단하여 <b>애초에 문제가 발생할 수 있는 상황 자체를 만들지 않는 방식으로 설계</b>되었습니다.
  
  대신 Java는 <b>인터페이스를 통한 다중 구현을 지원</b>합니다. 인터페이스는 구현체가 없는 추상 메서드만을 가지기 때문에 Diamond Problem이 발생하지 않으며, Java8 부터 인터페이스에 default 메서드가 추가되긴 했지만, 충돌 시 컴파일 타임에 오류를 발생시키며 명시적으로 구현하도록 강제함으로써 모호성을 해결하였습니다.
</details>
<details>
  <summary>CheckedException과 UncheckedException의 차이에 대해 설명해주세요.</summary><br>

  <b>CheckedException</b>은 <b>컴파일 시점에 반드시 예외 처리를 해야 하는 예외</b>입니다. `try-catch` 블록으로 처리하거나 `throws` 키워드로 상위 메서드에 예외를 위임해야 합니다. 만약 처리하지 않으면 컴파일 에러가 발생합니다. 대표적으로 `IOException`, `SQLException`, `ClassNotFoundException` 등이 있습니다.

  <b>UncheckedException</b>은 <b>컴파일 시점에 예외 처리를 강제하지 않는 예외</b>입니다. 개발자가 선택적으로 처리할 수 있고, 처리하지 않아도 컴파일은 됩니다. 하지만 런타임에 발생하면 프로그램이 비정상 종료될 수 있습니다. `RuntimeException`을 상속받는 예외들로, `NullPointerException`, `ArrayIndexOutOfBoundsException`, `IllegalArgumentException` 등이 있습니다.
  
  CheckedException은 접근하려는 파일이 존재하지 않거나, 네트워크 연결이 끊어지거나, 데이터베이스 접근에 실패하는 등 주로 <b>외부 요인</b>에 의해 발생하는 반면, UncheckedException은 null 참조, 배열 범위 초과, 잘못된 매개변수 전달 등 주로 <b>프로그래밍 오류</b>에 의해 발생합니다.
</details>
<details>
  <summary>try-with-resource에 대해 설명해주세요.</summary><br>

  Java 7에서 도입된 <b>자동 자원 관리 구문</b>으로, `AutoCloseable` 인터페이스를 구현한 자원들을 `try` 블록이 끝날 때 자동으로 `close()` 해주는 기능입니다.<br>

  기존에는 `finally` 블록에서 수동으로 `close()`를 호출해야 했지만, `try()` 문 안에 사용할 리소스 객체를 명시적으로 선언하여 사용하면, 로직이 완료될 때 JVM에서 자동으로 자원을 해제하도록 하여, 혹시 모를 메모리 누수와 코드 복잡성을 해결할 수 있습니다.
</details>
<details>
  <summary>오버로딩과 오버라이딩의 차이에 대해 설명해주세요.</summary><br>

  <b>오버로딩(Overloading)</b>은 <b>같은 클래스 내에서 같은 이름의 메서드를 여러 개 정의하는 것</b>입니다. 메서드 이름은 동일하지만 매개변수의 개수, 타입, 순서가 달라야 합니다.<br>

  <b>오버라이딩(Overriding)</b>은 <b>부모 클래스에서 정의된 메서드를 자식 클래스에서 재정의하는 것</b>입니다. 메서드의 이름, 매개변수, 리턴 타입과 같은 메서드 시그니처가 모두 동일해야 합니다.<br>
  
  즉, 오버로딩은 <b>편의성</b>을 위한 기능이고, 오버라이딩은 <b>다형성</b>을 위한 기능이라고 할 수 있습니다.
</details>
<details>
  <summary>HashMap, HashTable, ConcurrentHashMap의 차이에 대해 설명해주세요.</summary><br>

  `HashMap`은 Thread-unsafe한 자료구조입니다. 동기화 처리를 하지 않기 때문에 단일 스레드 환경에 사용하기에 적합하며, 가장 빠른 성능을 보여줍니다.<br>

  `HashTable`은 `HashMap`과 달리 모든 메서드가 `synchronized`로 동기화되어 있어서 Thread-safe 합니다. 단, 메서드 레벨에서 락(Lock)을 걸기 때문에 한 번에 하나의 스레드만 해당 메서드에 접근할 수 있어 성능이 상당히 떨어집니다. 따라서 최근에는 거의 사용하지 않는 레거시 클래스라고 볼 수 있습니다.<br>
  
  `ConcurrentHashMap`은 `HashTable`처럼 테이블 전체에 락을 거는게 아니라 버킷(Bucket) 레벨에 락을 걸어, 여러 스레드가 서로 다른 버킷에 대해서는 동시에 접근할 수 있도록 처리하여, 멀티 스레드 환경에서 최적화된 성능을 보여줍니다.
</details>
<details>
  <summary>new String()과 “”의 차이에 대해 설명해주세요.</summary><br>

  가장 큰 차이는 메모리 할당 방식입니다.<br>

  문자열 리터럴(`""`)은 JVM의 <b>String Pool</b>에 저장됩니다. 리터럴 방식으로 문자열을 선언할 경우 JVM은 String Pool에 해당 문자열이 이미 존재하는지 확인하고, 있다면 그 주소를 재사용하는 방식으로 동작합니다. 따라서 동일한 문자열의 경우 같은 메모리 주소를 참조하게 되며, 이를 통해 <b>메모리를 절약</b>할 수 있습니다.<br>
  
  반면 `new` 키워드를 사용하여 문자열 객체를 생성할 경우 힙 메모리에 새로운 `String` 객체를 생성합니다. 이 경우 설령 같은 내용이더라도 매번 새로운 객체가 만들어지게 되므로 <b>불필요한 객체 생성으로 인한 메모리 누수와 GC 부담이 증가</b>할 수 있습니다.
</details>
<details>
  <summary>Java의 리플렉션과 동적 프록시에 대해 설명해주세요.</summary><br>

  <b>리플렉션(Reflection)</b>은 <b>객체를 통해 클래스의 정보를 분석하여 런타임에 클래스의 동작을 검사하거나 조작하는 프로그래밍 기법</b>입니다. 클래스 파일의 위치나 이름만 있다면 해당 클래스의 정보를 얻어내고, 객체를 생성하는 것 또한 가능하게 해주어 유연한 프로그래밍이 가능합니다.

  리플렉션은 애플리케이션 개발보다는 <b>프레임워크</b>, <b>라이브러리</b> 개발에서 주로 사용됩니다. 프레임워크나 라이브러리는 사용자가 어떤 클래스를 만들지, 그 클래스에 어떤 필드나 메서드가 있을지 전혀 모르는 상태에서, 이러한 사용자 클래스들을 본인들이 만든 기능과 동적으로 연결시키기 위해 리플렉션을 사용합니다. 대표적인 예로 Spring, Hibernate, Lombok 등이 있습니다.
  
  <b>동적 프록시</b>는 <b>런타임에 프록시 객체를 동적으로 생성하는 기술</b>입니다. 기존의 정적 프록시와 달리, 컴파일 타임에 프록시 클래스를 미리 만들어두지 않고 실행 중에 필요할 때 생성하는 방식으로, <b>리플랙션을 활용한 대표적인 응용 사례</b>입니다.
  
  Java에서 동적 프록시를 구현하는 방법으로는 크게 두 가지가 있습니다.
  
  <b>JDK 동적 프록시</b>는 <b>인터페이스</b>를 기반으로 동작하며, 특정 인터페이스를 구현한 프록시 객체를 런타임에 생성하는 방식입니다.
  
  <b>CGLIB 동적 프록시</b>는 <b>클래스 기반</b>으로 동작해서 인터페이스 없이도 프록시를 만들 수 있습니다. 이는 바이트코드 조작을 통해 <b>타겟 클래스를 상속받은 서브클래스를 생성하는 방식</b>입니다. 해당 라이브러리의 경우 오히려 JDK 동적 프록시에 비해 성능이 좋으며, 그 효용성을 인정받아 스프링 프레임워크에서 기본으로 내장되어 사용되고 있습니다.
  
  이에 대한 가장 대표적인 사용 사례가 <b>Spring AOP</b>입니다. Spring에서 `@Transactional` 같은 어노테이션을 붙이면, 해당 메서드 호출 전후에 부가 기능이 실행되는데, 이게 바로 동적 프록시를 통해 구현됩니다.
  
  동적 프록시 기법을 사용하면 코드 중복을 줄이고, 횡단 관심사를 분리할 수 있으며, 런타임에 유연하게 프록시를 생성할 수 있습니다. 하지만 리플렉션 기법을 사용하기 때문에 성능 오버헤드가 있고, 디버깅이 어려울 수 있다는 단점도 존재합니다.
</details>
<details>
  <summary>JDK, JRE, JVM의 차이에 대해 설명해주세요.</summary><br>

  <b>JVM(Java Virtual Machine)</b>은 자바 바이트코드를 실행하는 가상 머신입니다. 이때 바이트코드를 해당 OS의 네이티브 코드로 변환해서 실행하며, 이를 통해 플랫폼 독립적인 실행 환경을 제공합니다. 또한 가비지 컬렉션을 통한 메모리 관리, 스레드 관리 등의 역할을 담당합니다.
  
  <b>JRE(Java Runtime Environment)</b>는 자바 프로그램을 실행하기 위한 환경입니다. JVM을 포함하고 있으며, 추가로 표준 라이브러리(java.lang, java.util 등)와 기타 실행에 필요한 파일들로 구성됩니다.
  
  <b>JDK(Java Development Kit)</b>는 자바로 개발을 하기 위한 전체적인 도구들의 모음입니다. JRE를 포함한 각종 개발 도구들(javac 컴파일러, javadoc, jar, debugger 등)을 포함합니다. 자바 애플리케이션을 개발, 컴파일, 실행, 디버깅할 수 있는 완전한 환경을 제공합니다.
</details>
<details>
  <summary>JVM의 메모리 구조에 대해 설명해주세요.</summary><br>

  JVM 메모리 영역은 크게 <b>메서드 영역, 힙 영역, 스택 영역, PC 레지스터, 네이티브 메서드 스택 영역</b>으로 나눌 수 있습니다. 여기서 메서드 영역과 힙 영역은 모든 스레드가 공유하는 영역이고, 나머지 스택 영역과 PC 레지스터, 네이티브 메서드 스택 영역은 스레드별로 독립적으로 생성되는 영역입니다.

  <b>메서드 영역</b>은 클래스 메타데이터, 상수 풀(Constant Pool), static 변수 등이 저장되는 영역입니다. 메서드 영역은 Java 7 버전까지는 JVM 메모리 영역에 PermGen으로 구현이 되었고, Java 8 버전 이후부터는 OS에 의해 관리되는 네이티브 메모리 영역에 Metaspace로 구현 되었습니다.
  
  <b>힙 영역</b>은 객체나 배열 같은 참조 타입이 저장되는 공간으로, GC의 대상이 되는 영역입니다. 힙은 효율적인 GC를 위해 Young Generation과 Old Generation으로 나뉘어 있고, Young Gerneration은 또다시 Eden 영역과 두 개의 Survivor 영역으로 나뉩니다. Eden 영역은 새로 생성된 객체들이 가장 먼저 할당되는 영역이며, GC에서 살아남은 객체들은 Survivor 영역으로 이동합니다. 그리고 Young Generation에서 age가 임계치까지 도달한 객체들은 Old Generation으로 이동하게 됩니다.
  
  <b>스택 영역</b>은 메서드 호출 시 생성되는 지역 변수, 매개 변수, 리턴 주소 등이 저장되는 영역입니다. 스택 영역은 데이터를 스택 프레임 단위로 관리하며, 메서드가 종료되면 해당 스택 프레임은 제거됩니다.
  
  <b>PC 레지스터</b>는 각 스레드가 현재 실행중인 JVM 명령어의 주소를 저장하는 영역입니다.
  
  <b>네이티브 메서드 스택 영역</b>은 JNI를 통해 호출되는 C/C++ 등의 네이티브 코드를 실행하기 위한 스택 영역입니다.
</details>
<details>
  <summary>Garbage Collector의 동작 원리에 대해 설명해주세요.</summary><br>

  GC의 기본 원리는 더 이상 사용되지 않는 객체들을 자동으로 찾아서 힙 메모리에서 해제하는 것입니다. 이때 가장 중요한 개념이 <b>도달 가능성(Reachability)</b>인데, GC Root라고 불리는 시작점들로부터 참조 체인을 따라가면서 도달할 수 있는 객체와 도달할 수 없는 객체를 분리한 후 Unreachable한 객체는 가비지(Garbage)로 판단하여 제거하는 방식입니다.
  
  이러한 수집 알고리즘을 Mark & Sweep이라고 하며 GC 알고리즘의 종류에 따라 메모리 단편화를 해결하기 위한 Compact 단계가 추가로 진행되기도 합니다.
</details>
<details>
  <summary>GC 알고리즘에 대해 설명해주세요.</summary><br>

  <b>Serial GC는</b> 가장 단순한 GC로, GC를 싱글 스레드로 처리하기 때문에 STW(Stop the World) 시간이 가장 긴 알고리즘입니다.

  <b>Parallel GC</b>는 Java 8의 디폴트 GC로, Serial GC를 멀티 스레드로 개선한 버전입니다. 여러 스레드가 병렬로 GC 작업을 수행해서 처리 시간을 단축시키지만, 여전히 STW 시간이 존재합니다.
  
  <b>CMS GC</b>는 Concurrent Mark Sweep의 줄임말로, 애플리케이션과 동시에 GC 작업을 수행해서 응답 시간을 개선하였습니다. 다만, Compaction 단계의 부재로 인한 메모리 단편화 문제와 복잡한 GC 과정으로 인한 CPU 사용량 문제로 인해 Java 14부터 제거되었습니다.
  
  <b>G1GC</b>는 Java 9부터 설정된 디폴트 GC으로, 큰 힙 메모리에서 낮은 지연 시간을 목표로 설계되었습니다. 힙을 여러 Region으로 나누고, 각 Region에 Eden, Survivor, Old 등의 역할을 동적으로 할당하는 방식이며, 이를 통해 탐색할 때 힙 전체를 탐색하는 것이 아니라 부분적으로(Region 단위로) 탐색함으로써 가비지가 많은 Region을 우선적으로 GC하여 효율성을 높였습니다.
  
  <b>ZGC</b>는 초저지연을 목표로 하는 최신 GC입니다. G1GC의 Region처럼, ZGC는 ZPage라는 영역을 사용하며, G1GC의 Region은 크기가 고정인데 비해 ZPage는 Small(2MB), Medium(32MB), Large(2MB 배수)로 동적으로 운영한다는 차이가 있습니다. ZGC는 Colored Pointer를 사용하여 객체의 상태를 관리하고 Load Barrier를 사용해서 안전한 메모리 접근을 보장함으로써 대부분의 작업을 동시에 수행하고, 힙 크기에 관계없이 10ms 이하의 STW 시간을 보장합니다.
</details>
<details>
  <summary>제네릭이란 무엇이고, 왜 사용하는지 설명해주세요.</summary><br>

  제네릭은 <b>클래스나 메서드에서 사용할 타입을 컴파일 타임에 지정할 수 있게 해주는 기능</b>입니다. 제네릭으로 작성된 클래스나 메서드의 경우에는 타입을 파라미터로 받아서 코드 작성 시점에는 구체적인 타입을 결정하지 않고, 그것을 실제로 사용할 때 타입을 지정할 수 있습니다.

  제네릭을 사용하는 가장 큰 이유는 <b>타입 안전성</b>을 확보하기 위해서입니다. 제네릭이 없던 시절(Java5 이전)에는 컬렉션에서 객체를 꺼낼 때마다 형변환을 해야했고, 이때 혹시라도 엉뚱한 타입의 객체가 컬렉션에 포함되어 있을 경우 런타임에 형변환 오류가 발생하는 문제가 있었습니다. 제네릭을 사용하면 컴파일 타임에 오류를 검출할 수 있어 보다 안전하고 명확한 프로그래밍이 가능합니다.
</details>
<details>
  <summary>어노테이션에 대해 설명해주세요.</summary><br>

  어노테이션은 <b>코드에 메타데이터를 추가하는 방법</b>으로, 클래스, 메서드, 필드 등에 추가 정보를 제공하며, 코드 자체의 동작에는 직접적인 영향을 주지 않습니다.

  어노테이션은 컴파일 시 사용할 정보를 컴파일러에게 제공하거나(`@Override` 등), 빌드 툴이 코드를 자동으로 생성할 때 필요한 정보를 제공하거나(`@Entity`, `@Component` 등), 런타임에 특정 기능을 처리할 때 필요한 정보를 전달하기 위해(`@RequestMapping`, `@Transactional` 등) 사용됩니다.
</details>
<details>
  <summary>동일성과 동등성에 대해 설명해주세요.</summary><br>

  <b>동일성(Identity)</b>은 두 객체가 메모리상에서 정말로 같은 객체인지를 의미합니다. `==` 연산자로 확인하며, <b>참조값(주소값)</b>이 같은지를 비교합니다.

  <b>동등성(Equality)</b>은 두 객체가 논리적으로 같은 값을 가지는지를 의미합니다. `equals()` 메서드로 확인하며, 객체의 <b>내용</b>이 같은지를 비교합니다.
</details>
<details>
  <summary>Java의 모든 클래스는 Object 클래스를 상속 받습니다. 그리고 Object 클래스에는 equals()와 hashCode() 메서드가 선언되어 있습니다. 이 메서드들은 각각 어떤 역할을 할까요?</summary><br>

  `equals()` 메서드는 두 객체의 논리적 동등성을 판단하는 역할을 합니다. `Object` 클래스의 기본 구현에서는 참조값을 비교하는 연산과 동일하게 동작하지만, 대부분의 클래스에서는 객체의 내용을 비교하도록 오버라이드해서 사용합니다.

  `hashCode()` 메서드는 해당 객체가 해시 테이블에 저장될 때 사용할 해시값을 반환하는 메서드입니다.

  중요한 점은, 이 둘이 <b>일관성</b>을 유지해야 한다는 점입니다. 즉, 두 객체에 대한 `equals()` 메서드의 결과가 `True`라면 두 객체의 해시값도 반드시 동일해야 합니다.
</details>
<details>
  <summary>hashCode()를 잘못 오버라이딩하면 HashMap과 같은 해시 컬렉션의 성능이 떨어질 수가 있습니다. 어떤 케이스일 때 그럴 수 있을까요?</summary><br>

  모든 객체가 같은 해시값을 반환하거나 해시값의 분포가 매우 불균등한 경우 모든 객체가 특정 버킷에 몰려서 연결 리스트나 트리 형태로 저장되며, 본래 O(1)의 시간 복잡도를 가지는 검색 속도가 최악의 경우 O(n)으로 떨어져 성능이 크게 악화될 수 있습니다.

  또한 `hashCode()`는 해시 컬렉션에 객체를 저장하거나 검색할 때마다 호출되므로, 해시값 계산 비용이 너무 높은 경우에도 성능이 악화될 수 있습니다.
</details>
<details>
  <summary>System.out.println() 메서드는 현업에서 절대 쓰지 말라고 하는 메서드인데요. 그 이유가 무엇일까요?</summary><br>

  가장 큰 문제는 성능입니다. `System.out.println()`은 내부적으로 `synchronized` 키워드를 포함하고 있어 동기적으로 동작하기 때문에 콘솔에 출력할 때마다 스레드가 블로킹되며, 이로 인한 성능저하가 발생하게 됩니다.

  또한 로그 레벨 제어가 불가능하기 때문에 필요에 따라 로그 출력을 조절할 수 없다는 문제도 존재합니다. 따라서 현업에서는 Logback 같은 로깅 프레임워크를 사용해서 로그 레벨을 제어하고 비동기 로깅으로 성능을 최적화하는 것이 일반적입니다.
</details>
<details>
  <summary>Serializable에 대해 설명해주세요.</summary><br>

  Serializable(직렬화)이란 자바에서 사용되는 데이터를 다른 자바 시스템에서 사용할 수 있도록 연속적인 바이트 스트림 형태의 데이터로 변환하는 기술을 말합니다.

  직렬화를 사용하면 JVM 메모리에만 상주하는 데이터를 영속화할 수 있으며, 시스템이 종료되더라도 이를 보존할 수 있습니다. 또한 영속화된 데이터이기 때문에 네트워크로 전송이 가능합니다.

  `Serializable은` Java의 마커 인터페이스로, 해당 객체를 바이트 스트림으로 변환할 수 있다는 것을 JVM에게 알려주는 역할을 합니다. 실제로 구현해야 할 메서드는 없고, 단순히 직렬화가 가능함을 표시하는 것입니다.

  `serialVersionUID`는 Java의 직렬화 과정에서 클래스의 버전을 식별하는 고유 식별자로, 이 값을 통해 직렬화할 때와 역직렬화할 때의 클래스 버전이 같은지 확인할 수 있으며, 직렬화된 데이터의 안정성과 버전 호환성을 관리할 수 있습니다.
</details>
<details>
  <summary>Virtual Thread에 대해 설명해주세요.</summary><br>

  Virtual Thread는 기존에 네이티브 스레드(Kernel-Level-Thread)와 플랫폼 스레드(User-Level-Thread)를 1대1 매핑하여 사용하던 JVM의 스레드 모델을 개선하여, 여러 개의 가상 스레드를 하나의 네이티브 스레드에 할당해서 사용하는 모델로, Java 21에서 정식 도입된 경량 스레드입니다.

  가상 스레드의 가장 큰 특징은 메모리 사용량이 극적으로 적다는 점입니다. 기존 플랫폼 스레드가 1~2MB 정도 크기의 스택을 가지는 반면, 가상 스레드는 몇 KB 수준으로 시작해서 필요에 따라 동적으로 확장됩니다.

  가상 스레드는 내부적으로 적은 수의 캐리어 스레드(플랫폼 스레드) 위에서 실행됩니다. I/O 작업이나 블로킹이 발생하면 가상 스레드는 캐리어 스레드에서 분리되고, 다른 가상 스레드가 그 자리를 사용하는데 이를 'unmounting'이라고 부릅니다.

  가상 스레드는 특히 I/O 집약적인 작업에서 성능이 뛰어납니다. 기존에는 스레드가 I/O를 기다리는 동안 네이티브 스레드가 블로킹되었는데, 가상 스레드는 블로킹 시 자원을 반납하고 이를 통해 다른 작업을 처리할 수 있어서 처리량이 크게 향상됩니다.

  단, CPU 집약적 작업에서는 기존 스레드와 성능 차이가 크지 않고, `synchronized` 블록에서는 여전히 네이티브 스레드가 블로킹될 수 있어서 이러한 경우에는 ReentrantLock 사용을 권장하고 있습니다.

  `synchronized`는 OS가 네이티브 스레드를 기준으로 락을 관리하기 때문에 가상 스레드가 다른 네이티브 스레드로 이동할 수 없지만, ReentrantLock은 JVM이 가상 스레드를 기준으로 락을 관리하기 때문에 자유롭게 이동할 수 있습니다.
</details>

---

### 🧬 Architecture
<details>
  <summary>MSA에 대해 설명해주세요.</summary><br>

  MSA(Microservices Architecture)란 <b>하나의 큰 애플리케이션을 여러 개의 작은 서비스로 나누어서 개발하고 운영하는 아키텍처 패턴</b>입니다.<br>

  이를 통해 서비스별로 독립적인 개발, 배포가 가능해서 전체 시스템을 중단하지 않고도 특정 기능만 업데이트할 수 있고, 특정 서비스에 장애가 발생했을 때 장애의 전파를 최소화할 수 있습니다.<br>
  
  단, 서비스 간 통신이 네트워크를 통해 이루어지기 때문에 네트워크 오버헤드 및 복잡도가 증가하고, 데이터의 일관성이 떨어지는 문제가 발생할 수 있습니다.
</details>
<details>
  <summary>MSA 환경에서 데이터의 일관성을 보장하는 방법에 대해 설명해주세요.</summary><br>

  <b>2PC(2-Phase-Commit)</b>는 분산 트랜잭션을 처리하기 위한 전통적인 방법으로, 트랜잭션의 전체적인 진행을 관리하는 코디네이터(Cordinator)와 트랜잭션을 처리하는데 참여하는 참여자(Participant)간에 소통하며 <b>준비 단계(Prepare Phase)</b>와 <b>커밋 단계(Commit Phase)</b>를 거쳐 데이터의 일관성을 보장하는 방법입니다.<br>

  <b>SAGA 패턴</b>은 약간의 일관성을 포기하고 Eventual Consistency(최종 일관성)를 보장하여 효율성을 높이기 위한 패턴입니다.<br>
  2PC에서는 여러 트랜잭션을 하나의 트랜잭션으로 묶어서 처리하지만, SAGA 패턴은 긴 트랜잭션을 여러 개의 짧은 로컬 트랜잭션으로 분리하여 처리합니다.<br>
  이때 각 트랜잭션은 다른 트랜잭션의 완료를 기다리지 않고 독립적으로 실행되며, 따라서 트랜잭션의 원자성을 보장하기 위해 만약 중간에 문제가 생길 경우에는 <b>보상 트랜잭션</b>이 실행되어 이전 트랜잭션을 롤백하는 것과 같은 효과를 가져옵니다.

  > <b>전통적인 ACID 일관성 vs SAGA의 최종 일관성</b><br>
  > 전통적인 ACID 트랜잭션에서는 <b>Strong Consistency(강한 일관성)</b>을 제공합니다. 즉, 트랜잭션이 완료되는 순간 모든 데이터가 일관된 상태를 유지하며, 하나의 작업이라도 실패하면 전체를 롤백하여 원래 상태로 되돌립니다.<br>
  > SAGA 패턴은 이와 다른 접근 방식을 사용합니다. SAGA 패턴에서는 각 트랜잭션이 독립적으로 실행되며 중간에 문제가 발생할 경우 이미 완료된 트랜잭션들을 대상으로 역순으로 보장 트랜잭션을 실행합니다. 때문에 이 과정에서 <b>일시적으로 불일치 상태</b>가 존재할 수 있습니다. 다만 보상 트랜잭션이 모두 완료된 시점에는 최종적으로 일관된 상태에 도달하기 때문에 SAGA 패턴은 <i>"약간의 일관성을 포기하고 최종 일관성을 보장한다"</i>라고 말할 수 있습니다.
</details>

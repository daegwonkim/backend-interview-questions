<div align="center">
  <a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.demolab.com?font=Black+Han+Sans&size=40&duration=3000&pause=1000&color=0EBB12&center=true&vCenter=true&width=450&lines=%EB%B0%B1%EC%97%94%EB%93%9C+%EA%B0%9C%EB%B0%9C%EC%9E%90+%EB%A9%B4%EC%A0%91+%EC%A7%88%EB%AC%B8+%EC%A0%95%EB%A6%AC" alt="Typing SVG" /></a>  
</div>

## 🎯 Introduction
백엔드 개발 면접을 준비하면서 정리한 질문과 답변 모음집입니다.  
CS, 프로그래밍 언어, 프레임워크, 데이터베이스, Web, 보안 관련 내용을 다룹니다.

## 📌 Index
- [CS](#-cs)
- [Programing Language](#-programing-language)
- [Framework](#-framework)
- [Database](#-database)
- [Web](#-web)
- [Security](#-security)

## 💡 Questions
### 🖥 CS
#### 🧠 Operation System
<details>
  <summary>프로세스와 스레드의 차이에 대해 설명해주세요.</summary><br>
  
  프로세스와 스레드는 운영체제에서 <b>실행의 단위</b>를 나타내는 개념입니다.<br>
  
  <b>프로세스</b>는 현재 실행 중인 프로그램을 의미하고, 각 프로세스는 독립적인 메모리 공간을 가지고 있으며, 다른 프로세스와 완전히 분리되어 있습니다.<br>
  
  <b>스레드</b>는 프로세스 내에서 실행되는 작업의 단위이며, 하나의 프로세스 안에 여러 개의 스레드가 있을 수 있습니다. 스레드들은 같은 프로세스의 메모리 공간(스택 영역 제외)을 공유합니다.<br>

  주요 차이점을 요약하면 다음과 같습니다.
  1. 프로세스는 독립적인 메모리 공간을 가지지만 스레드는 코드, 데이터, 힙 영역을 공유하고 스택 영역만 따로 갖습니다.<br>
  2. 프로세스 간에는 서로 통신을 통해서 자원을 공유하고 데이터를 주고받아야 하지만, 스레드는 공유 메모리를 통해서 쉽게 데이터를 공유할 수 있습니다.<br>
  3. 프로세스는 하나의 프로세스가 죽어도 다른 프로세스에 영향을 주지 않지만, 스레드는 하나에 문제가 생기면 해당 스레드를 포함하고 있는 전체 프로세스가 영향을 받을 수 있습니다.
</details>
<details>
  <summary>메모리 구조에 대해 설명해주세요.</summary><br>
  
  메모리 구조는 크게 코드 영역, 데이터 영역, 힙 영역, 스택 영역으로 구분됩니다.<br>
  
  <b>코드 영역</b>은 실행할 프로그램의 코드가 저장되는 영역으로, 컴파일된 기계어 명령어들이 저장됩니다.<br>
  사용자가 프로그램 실행 명령을 내리면 OS에서는 디스크에서 메모리의 코드 영역으로 실행 코드를 올리게 되고, CPU는 코드 영역에 저장된 명령어를 하나씩 실행하게 됩니다.<br>

  <b>데이터 영역</b>은 프로그램 실행에 필요한 전역 변수와 정적 변수가 저장되는 영역입니다.<br>
  
  <b>힙 영역</b>은 동적으로 할당되는 메모리 공간으로, `malloc()`이나 `new`와 같은 함수로 런타임에 메모리를 요청할 경우 사용됩니다.<br>
  
  <b>스택 영역</b>은 함수 호출과 관련된 데이터가 저장되는 공간으로, 매개 변수나 지역 변수와 같은 데이터가 스택 프레임의 형태로 저장됩니다.<br>
  함수가 호출되면 스택에 스택 프레임이 쌓이고, 함수가 종료되면 스택 프레임이 제거되는 방식으로 동작합니다.
</details>
<details>
  <summary>컨텍스트 스위칭에 대해 설명해주세요.</summary><br>

  컨텍스트 스위칭이란 <b>CPU가 현재 실행중인 프로세스나 스레드의 실행을 중단하고 다른 프로세스나 스레드로 전환하는 과정</b>을 말합니다.<br>

  현재 실행중인 프로세스의 상태를 <b>PCB(Process Control Block)</b>에 저장하고, 다음에 실행할 프로세스의 상태를 PCB에서 불러와서 CPU 레지스터에 복원하는 방식으로 동작합니다.<br>

  컨텍스트 스위칭이 발생하는 기준은 다음과 같습니다.
  1. 시분할 시스템에서 타임 슬라이스가 끝난 경우
  2. I/O 작업으로 프로세스가 대기 상태에 들어간 경우
  3. 우선순위가 높은 프로세스가 대기열에 들어선 경우
  4. 프로세스가 종료된 경우
</details>
<details>
  <summary>CPU 스케줄링 알고리즘에 대해 설명해주세요.</summary><br>

  CPU 스케줄링 알고리즘이란 <b>여러 프로세스가 CPU를 사용하려고 할 때 어떤 순서로 CPU를 할당할지 결정하는 방법</b>을 말합니다.<br>

  <b>FCFS(First Come First Served) 스케줄링 기법</b>은 먼저 도착한 프로세스부터 처리하는 가장 간단한 방식으로, 공정하지만 작업 시간이 긴 프로세스가 먼저 도착하면 뒤의 짧은 작업들이 오래 기다려야 하는 <b>콘보이 현상</b>이 발생할 수 있습니다.

  <b>SJF(Shortest Job First) 스케줄링 기법</b>은 실행 시간이 가장 짧은 프로세스부터 처리하는 방식으로, 평균 대기 시간을 최소화할 수 있지만, 프로세스의 실행 시간을 미리 알기가 어렵고 실행 시간이 긴 프로세스의 경우에는 계속 실행이 지연되어 <b>기아 현상</b>이 발생할 수 있습니다.<br>

  <b>Round Robin 스케줄링 기법</b>은 각 프로세스에게 동일한 시간 할당량(타임 슬라이스)을 주고 돌아가면서 실행시키는 방식으로, 응답시간이 좋고 공정하지만 타임 슬라이스가 너무 짧으면 <b>컨텍스트 스위칭 오버헤드</b>로 인해 성능에 문제가 생길 수 있습니다.<br>

  <b>우선순위 스케줄링 기법</b>은 각 프로세스에 우선순위를 부여해서 높은 우선순위의 프로세스부터 처리하는 방식으로, 중요한 작업을 먼저 처리할 수 있지만 낮은 우선순위 프로세스의 경우 계속 실행이 지연되어 <b>기아 현상</b>이 발생할 수 있습니다.<br>

  <b>다단계 피드백 큐 스케줄링 기법</b>은 여러 개의 큐를 두고 프로세스의 행동에 따라 우선순위를 동적으로 조정하는 방식으로, CPU 집약적인 프로세스는 낮은 우선순위로, I/O 집약적인 프로세스는 높은 우선순위로 관리하며 CPU 실행 효율성을 높이는 기법입니다.

  > <b>콘보이 현상</b><br>
  > 콘보이 현상이란 작업 시간이 긴 프로세스에 의해 다른 프로세스의 실행이 전부 늦춰지는 현상을 말합니다.<br>
  > FCFS 스케줄링은 <b>비선점형 스케줄링 방식</b>으로, I/O 작업으로 인해 프로세스가 대기 상태로 전환되거나 프로세스가 완전히 종료되기 전까지는 다른 프로세스를 실행할 수 없기 때문에 이러한 현상이 발생할 수 있습니다.

  > <b>기아 현상</b><br>
  > 기아 현상이란 특정 프로세스가 계속해서 자원을 할당받지 못해 무한정 기다리게 되는 상황을 말합니다.<br>
  > 즉, SJF나 우선순위 스케줄링 방식에서 우선순위가 높은 프로세스들이 계속 들어오면서 우선순위가 낮은 프로세스는 영원히 실행되지 못하는 것을 의미하며, 이에 대한 가장 일반적인 해결책은 프로세스가 오래 기다릴수록 우선순위를 점진적으로 높여주는 <b>에이징(aging) 기법</b>을 사용하는 것입니다.
</details>
<details>
  <summary>선점형 스케줄링과 비선점형 스케줄링의 차이에 대해 설명해주세요.</summary><br>

  선점형 스케줄링과 비선점형 스케줄링은 <b>현재 실행중인 프로세스로부터 CPU를 강제로 빼앗을 수 있는지에 대한 개념</b>을 말합니다.<br>

  <b>비선점형 스케줄링</b>에서는 한 번 CPU를 할당받은 프로세스는 작업이 완료되거나 자발적으로 CPU 반납하지 않는 이상 계속 실행됩니다.<br>
  즉, 운영체제가 강제로 CPU를 빼앗을 수 없으며, 대표적인 예로 FCFS, SJF 스케줄링이 있습니다.<br>
  비선점형 스케줄링은 구현이 간단하고 컨텍스트 스위칭 오버헤드가 적지만, 작업 시간이 긴 프로세스가 CPU를 독점할 경우 응답 시간이 나빠질 수 있습니다.<br>

  <b>선점형 스케줄링</b>에서는 운영체제가 필요에 따라 현재 실행중인 프로세스로부터 CPU를 강제로 빼앗을 수 있습니다.<br>
  타임 슬라이스가 끝나거나 더 높은 우선순위 프로세스가 나타나면 현재 프로세스를 중단시키고 다른 프로세스를 실행하는 방식으로, 대표적인 예로 Round Robin이나 우선순위 스케줄링이 있습니다.<br>
  선점형 스케줄링은 응답 시간이 좋고 공정하지만, 컨텍스트 스위칭 오버헤드가 커질 수 있습니다.
</details>
<details>
  <summary>동기와 비동기의 차이에 대해 설명해주세요.</summary><br>

  동기와 비동기는 <b>작업의 실행 방식과 결과를 기다리는 방법에 대한 개념</b>을 말합니다.<br>

  <b>동기(Synchronous)</b>란 작업을 순차적으로 실행하는 방식으로, 하나의 작업이 완전이 끝날 때까지 기다렸다가 다음 작업을 실행합니다.<br>
  동기 방식은 코드가 직관적이고 이해하기 쉽지만, 느린 작업이 포함되어 있으면 전체적인 성능에 악영향을 미칠 수 있다는 특징을 갖고 있습니다.<br>

  <b>비동기(Asynchronous)</b>란 작업을 시작한 후 해당 작업에 대한 완료를 기다리지 않고 또 다른 작업 요청을 받아서 처리하는 방식으로, 나중에 작업이 완료된 것이 감지되면 그때 결과를 처리합니다.<br>
  비동기 방식은 효율적이고 응답성이 좋지만, 코드가 복잡해지고 디버깅이 어려워질 수 있다는 특징을 갖고 있습니다.
</details>
<details>
  <summary>Blocking I/O와 Non-blocking I/O의 차이에 대해 설명해주세요.</summary><br>

  Blocking I/O와 Non-blocking I/O는 <b>입출력 작업을 처리하는 방식에 대한 개념</b>을 말합니다.<br>

  <b>Blocking I/O</b>는 I/O 작업을 요청한 후 그 작업이 완료될 때까지 스레드가 대기하는 방식으로, 예를 들어 파일을 읽는 함수를 호출하면 파일 읽기가 완전히 끝날 때까지 해당 스레드는 다른 작업을 수행할 수 없게 됩니다.<br>
  코드는 간단하지만 효율성이 떨어진다는 특징을 갖고 있습니다.<br>

  <b>Non-blocking I/O</b>는 I/O 작업을 요청한 후 스레드가 커널로부터 바로 제어권을 반환 받아서 다른 작업을 처리할 수 있는 방식으로, 이후 polling이나 커널의 system call을 통해 작업이 완료되었음을 확인합니다.<br>
  Blocking 방식에 비해 효율적이지만, polling 방식을 사용할 경우 CPU 사용량이 늘어날 수 있습니다.
</details>
